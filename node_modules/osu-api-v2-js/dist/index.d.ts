/// <reference types="node" resolution-mode="require"/>
import { RequestInit } from "node-fetch";
import { WebSocket } from "ws";
import { User } from "./user.js";
import { Beatmap } from "./beatmap.js";
import { Beatmapset } from "./beatmapset.js";
import { Multiplayer } from "./multiplayer.js";
import { Score } from "./score.js";
import { Ranking } from "./ranking.js";
import { Event } from "./event.js";
import { Changelog } from "./changelog.js";
import { Forum } from "./forum.js";
import { WikiPage } from "./wiki.js";
import { NewsPost } from "./news.js";
import { Home } from "./home.js";
import { Scope, Spotlight } from "./misc.js";
import { Chat } from "./chat.js";
import { Comment } from "./comment.js";
export { User } from "./user.js";
export { Beatmap } from "./beatmap.js";
export { Beatmapset } from "./beatmapset.js";
export { Multiplayer } from "./multiplayer.js";
export { Score } from "./score.js";
export { Ranking } from "./ranking.js";
export { Event } from "./event.js";
export { Changelog } from "./changelog.js";
export { Forum } from "./forum.js";
export { WikiPage } from "./wiki.js";
export { NewsPost } from "./news.js";
export { Home } from "./home.js";
export { Ruleset, Mod, Scope, Spotlight } from "./misc.js";
export { Chat } from "./chat.js";
export { WebSocket } from "./websocket.js";
export { Comment } from "./comment.js";
/**
 * Generates a link for users to click on in order to use your application!
 * @param client_id The Client ID, find it at https://osu.ppy.sh/home/account/edit#new-oauth-application
 * @param redirect_uri The specified Application Callback URL, aka where the user will be redirected upon clicking the button to authorize
 * @param scopes What you want to do with/as the user
 * @param server The API server (defaults to **https://osu.ppy.sh**, leave as is if you don't know exactly what you're doing)
 * @returns The link people should click on
 */
export declare function generateAuthorizationURL(client_id: number, redirect_uri: string, scopes: Scope[], server?: string): string;
/** If the {@link API} throws an error, it should always be an {@link APIError}! */
export declare class APIError {
    /** The reason why things didn't go as expected */
    message: string;
    /** The server to which the request was sent */
    server: string;
    /** The method used for this request (like "get", "post", etc...) */
    method: string;
    /** The type of resource that was requested from the server */
    endpoint: string;
    /** The filters that were used to specify what resource was wanted */
    parameters: object;
    /** The status code that was returned by the server, if there is one */
    status_code?: number;
    /** The error that caused the api to throw an {@link APIError} in the first place, if there is one */
    original_error?: Error;
    constructor(message: string, server: string, method: string, endpoint: string, parameters: object, status_code?: number, original_error?: Error);
}
/** You can create an API instance without directly providing an access_token by using {@link API.createAsync}! */
export declare class API {
    private _access_token;
    /** The key that allows you to talk with the API */
    get access_token(): string;
    set access_token(token: string);
    private _token_type;
    /** Should always be "Bearer" */
    get token_type(): string;
    set token_type(token: string);
    private _expires;
    /** The expiration date of your access_token */
    get expires(): Date;
    set expires(date: Date);
    private _refresh_token?;
    /**
     * Valid for an unknown amount of time, allows you to get a new token without going through the Authorization Code Grant again!
     * Use {@link API.refreshToken} to do that
     */
    get refresh_token(): string | undefined;
    set refresh_token(token: string | undefined);
    private _refresh_on_401;
    /** If true, upon failing a request due to a 401, it will use the {@link API.refresh_token} if it exists (defaults to **true**) */
    get refresh_on_401(): boolean;
    set refresh_on_401(refresh: boolean);
    private _refresh_on_expires;
    /**
     * If true, the application will silently use the {@link API.refresh_token} right before the {@link API.access_token} expires,
     * as determined by {@link API.expires} (defaults to **true**)
     */
    get refresh_on_expires(): boolean;
    set refresh_on_expires(enabled: boolean);
    private _refresh_timeout?;
    get refresh_timeout(): API["_refresh_timeout"];
    set refresh_timeout(timeout: NodeJS.Timeout);
    private _client;
    /** The details of your client, which you've got from https://osu.ppy.sh/home/account/edit#oauth */
    get client(): {
        id: number;
        secret: string;
    };
    set client(client: {
        id: number;
        secret: string;
    });
    private _server;
    /**
     * The base url of the server where the requests should land (defaults to **https://osu.ppy.sh**)
     * @remarks For tokens, requests will be sent to the `oauth/token` route, other requests will be sent to the `api/v2` route
     */
    get server(): string;
    set server(server: string);
    private _user?;
    /** The osu! user id of the user who went through the Authorization Code Grant */
    get user(): number | undefined;
    set user(user: number | undefined);
    private _scopes?;
    /** The {@link Scope}s your application has, assuming it acts as a user */
    get scopes(): Scope[] | undefined;
    set scopes(scopes: Scope[] | undefined);
    private _verbose?;
    /** Which events should be logged (defaults to **none**) */
    get verbose(): "all" | "none" | "errors" | undefined;
    set verbose(verbose: "all" | "none" | "errors" | undefined);
    private _timeout;
    /**
     * The maximum **amount of seconds** requests should take before returning an answer (defaults to **20**)
     * @remarks 0 means no maximum, no timeout
     */
    get timeout(): number;
    set timeout(timeout: number);
    private _retry;
    /** Configure how this instance should behave when it comes to automatically retrying a request */
    get retry(): {
        /** If true, doesn't retry under any circumstances (defaults to **false**) */
        disabled: boolean;
        /** In seconds, how long should it wait until retrying? (defaults to **2**) */
        delay: number;
        /** How many retries maximum before throwing an {@link APIError} (defaults to **5**) */
        maximum_amount: number;
        /** Should it retry a request upon successfully refreshing the token due to {@link API.refresh_on_401} being `true`? (defaults to **true**) */
        on_automatic_refresh: boolean;
        /** Should it retry a request if that request failed because it has been aborted by the {@link API.timeout}? (defaults to **false**) */
        on_timeout: boolean;
        /** Upon failing a request and receiving a response, because of which received status code should the request be retried? (defaults to **[429]**) */
        on_status_codes: number[];
    };
    set retry(retry: {
        /** If true, doesn't retry under any circumstances (defaults to **false**) */
        disabled: boolean;
        /** In seconds, how long should it wait until retrying? (defaults to **2**) */
        delay: number;
        /** How many retries maximum before throwing an {@link APIError} (defaults to **5**) */
        maximum_amount: number;
        /** Should it retry a request upon successfully refreshing the token due to {@link API.refresh_on_401} being `true`? (defaults to **true**) */
        on_automatic_refresh: boolean;
        /** Should it retry a request if that request failed because it has been aborted by the {@link API.timeout}? (defaults to **false**) */
        on_timeout: boolean;
        /** Upon failing a request and receiving a response, because of which received status code should the request be retried? (defaults to **[429]**) */
        on_status_codes: number[];
    });
    /**
     * **Please use {@link API.createAsync} instead of the default constructor** if you don't have at least an {@link API.access_token}!
     * An API object without an `access_token` is pretty much useless!
     */
    constructor(properties: Partial<API>);
    /**
     * The normal way to create an API instance! Make sure to `await` it
     * @param client The ID and the secret of your client, can be found on https://osu.ppy.sh/home/account/edit#new-oauth-application
     * @param user If the instance is supposed to represent a user, use their Authorization Code and the Application Callback URL of your application!
     * @returns A promise with an API instance
     */
    static createAsync(client: {
        id: number;
        secret: string;
    }, user?: {
        /** The Application Callback URL; Where the User has been redirected to after saying "okay" to your application doing stuff */
        redirect_uri: string;
        /** The code that appeared as a GET argument when they got redirected to the Application Callback URL (`redirect_uri`) */
        code: string;
    }, verbose?: "none" | "errors" | "all", server?: string, 
    /** @remarks In **seconds** */
    timeout?: number): Promise<API>;
    /**
     * You can use this to specify additional settings for the method you're going to call, such as `headers`, an `AbortSignal`, and more advanced things!
     * @example
     * ```ts
     * const controller = new AbortController() // this controller can be used to abort any request that uses its signal!
     * const user = await api.withSettings({signal: controller.signal}).getUser(7276846)
     * ```
     * @param additional_fetch_settings You may get more info at https://www.npmjs.com/package/node-fetch#fetch-options
     * @returns A special version of the `API` that changes how requests are done
     */
    withSettings(additional_fetch_settings: ChildAPI["additional_fetch_settings"]): ChildAPI;
    /**
     * Get a websocket to get WebSocket events from!
     * @param server Where the "notification websocket/server" is
     * (defaults to **the {@link API.server}'s protocol and a maximum of 1 subdomain being replaced by "wss://notify."** (so usually `wss://notify.ppy.sh`))
    */
    generateWebSocket(server?: string): WebSocket;
    /**
     * Use this instead of `console.log` to log any information
     * @param is_error Is the logging happening because of an error?
     * @param to_log Whatever you would put between the parentheses of `console.log()`
     */
    private log;
    /** Add, remove, change the timeout used for refreshing the token automatically whenever certain properties change */
    private updateRefreshTimeout;
    /**
     * Set most of an `api`'s properties, like tokens, token_type, scopes, expiration_date
     * @param body An Object with the client id & secret, grant_type, and stuff that depends of the grant_type
     * @param api The `api` which will see its properties change
     * @returns `api`, just in case, because in theory it should modify the original object
     */
    private getAndSetToken;
    /** @returns Whether or not the token has been refreshed */
    refreshToken(): Promise<boolean>;
    /** Revoke your current token! Revokes the refresh token as well */
    revokeToken(): Promise<true>;
    /**
     * The function that directly communicates with the API! Almost every functions of the API object uses this function!
     * @param method The type of request, each endpoint uses a specific one (if it uses multiple, the intent and parameters become different)
     * @param endpoint What comes in the URL after `api/`
     * @param parameters The things to specify in the request, such as the beatmap_id when looking for a beatmap
     * @param settings Additional settings **to add** to the current settings of the `fetch()` request
     * @param info Context given by a prior request
     * @returns A Promise with the API's response
     */
    request(method: "get" | "post" | "put" | "delete", endpoint: string, parameters?: {
        [k: string]: any;
    }, settings?: ChildAPI["additional_fetch_settings"], info?: {
        number_try: number;
        just_refreshed: boolean;
    }): Promise<any>;
    /** {@inheritDoc Beatmap.lookup} @group Beatmap Functions */
    readonly lookupBeatmap: typeof Beatmap.lookup;
    /** {@inheritDoc Beatmap.getOne} @group Beatmap Functions */
    readonly getBeatmap: typeof Beatmap.getOne;
    /** {@inheritDoc Beatmap.getMultiple} @group Beatmap Functions */
    readonly getBeatmaps: typeof Beatmap.getMultiple;
    /** {@inheritDoc Beatmap.DifficultyAttributes.get} @group Beatmap Functions */
    readonly getBeatmapDifficultyAttributes: typeof Beatmap.DifficultyAttributes.get;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getOsu} @group Beatmap Functions */
    readonly getBeatmapDifficultyAttributesOsu: typeof Beatmap.DifficultyAttributes.getOsu;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getTaiko} @group Beatmap Functions */
    readonly getBeatmapDifficultyAttributesTaiko: typeof Beatmap.DifficultyAttributes.getTaiko;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getFruits} @group Beatmap Functions */
    readonly getBeatmapDifficultyAttributesFruits: typeof Beatmap.DifficultyAttributes.getFruits;
    /** {@inheritDoc Beatmap.DifficultyAttributes.getMania} @group Beatmap Functions */
    readonly getBeatmapDifficultyAttributesMania: typeof Beatmap.DifficultyAttributes.getMania;
    /** {@inheritDoc Beatmap.Pack.getOne} @group Beatmap Functions */
    readonly getBeatmapPack: typeof Beatmap.Pack.getOne;
    /** {@inheritDoc Beatmap.Pack.getMultiple} @group Beatmap Functions */
    readonly getBeatmapPacks: typeof Beatmap.Pack.getMultiple;
    /** {@inheritDoc Beatmap.getScores} @group Beatmap Functions */
    readonly getBeatmapScores: typeof Beatmap.getScores;
    /** {@inheritDoc Beatmap.getSoloScores} @group Beatmap Functions */
    readonly getBeatmapSoloScores: typeof Beatmap.getSoloScores;
    /** {@inheritDoc Beatmap.UserScore.getOne} @group Beatmap Functions */
    readonly getBeatmapUserScore: typeof Beatmap.UserScore.getOne;
    /** {@inheritDoc Beatmap.UserScore.getMultiple} @group Beatmap Functions */
    readonly getBeatmapUserScores: typeof Beatmap.UserScore.getMultiple;
    /** {@inheritDoc Beatmapset.search} @group Beatmapset Functions */
    readonly searchBeatmapsets: typeof Beatmapset.search;
    /** {@inheritDoc Beatmapset.lookup} @group Beatmapset Functions */
    readonly lookupBeatmapset: typeof Beatmapset.lookup;
    /** {@inheritDoc Beatmapset.getOne} @group Beatmapset Functions */
    readonly getBeatmapset: typeof Beatmapset.getOne;
    /** {@inheritDoc Beatmapset.Discussion.getMultiple} @group Beatmapset Functions */
    readonly getBeatmapsetDiscussions: typeof Beatmapset.Discussion.getMultiple;
    /** {@inheritDoc Beatmapset.Discussion.Post.getMultiple} @group Beatmapset Functions */
    readonly getBeatmapsetDiscussionPosts: typeof Beatmapset.Discussion.Post.getMultiple;
    /** {@inheritDoc Beatmapset.Discussion.Vote.getMultiple} @group Beatmapset Functions */
    readonly getBeatmapsetDiscussionVotes: typeof Beatmapset.Discussion.Vote.getMultiple;
    /** {@inheritDoc Beatmapset.Event.getMultiple} @group Beatmapset Functions */
    readonly getBeatmapsetEvents: typeof Beatmapset.Event.getMultiple;
    /** {@inheritDoc Changelog.Build.lookup} @group Changelog Functions */
    readonly lookupChangelogBuild: typeof Changelog.Build.lookup;
    /** {@inheritDoc Changelog.Build.getOne} @group Changelog Functions */
    readonly getChangelogBuild: typeof Changelog.Build.getOne;
    /** {@inheritDoc Changelog.Build.getMultiple} @group Changelog Functions */
    readonly getChangelogBuilds: typeof Changelog.Build.getMultiple;
    /** {@inheritDoc Changelog.UpdateStream.getAll} @group Changelog Functions */
    readonly getChangelogStreams: typeof Changelog.UpdateStream.getAll;
    /** {@inheritDoc Chat.keepAlive} @group Chat Functions */
    readonly keepChatAlive: typeof Chat.keepAlive;
    /** {@inheritDoc Chat.Message.getMultiple} @group Chat Functions */
    readonly getChatMessages: typeof Chat.Message.getMultiple;
    /** {@inheritDoc Chat.Message.send} @group Chat Functions */
    readonly sendChatMessage: typeof Chat.Message.send;
    /** {@inheritDoc Chat.Message.sendPrivate} @group Chat Functions */
    readonly sendChatPrivateMessage: typeof Chat.Message.sendPrivate;
    /** {@inheritDoc Chat.Channel.getOne} @group Chat Functions */
    readonly getChatChannel: typeof Chat.Channel.getOne;
    /** {@inheritDoc Chat.Channel.getAll} @group Chat Functions */
    readonly getChatChannels: typeof Chat.Channel.getAll;
    /** {@inheritDoc Chat.Channel.markAsRead} @group Chat Functions */
    readonly markChatChannelAsRead: typeof Chat.Channel.markAsRead;
    /** {@inheritDoc Chat.Channel.createPrivate} @group Chat Functions */
    readonly createChatPrivateChannel: typeof Chat.Channel.createPrivate;
    /** {@inheritDoc Chat.Channel.createAnnouncement} @group Chat Functions */
    readonly createChatAnnouncementChannel: typeof Chat.Channel.createAnnouncement;
    /** {@inheritDoc Chat.Channel.joinOne} @group Chat Functions */
    readonly joinChatChannel: typeof Chat.Channel.joinOne;
    /** {@inheritDoc Chat.Channel.leaveOne} @group Chat Functions */
    readonly leaveChatChannel: typeof Chat.Channel.leaveOne;
    /** {@inheritDoc Comment.getOne} @group Comment Functions */
    readonly getComment: typeof Comment.getOne;
    /** {@inheritDoc Comment.getMultiple} @group Comment Functions */
    readonly getComments: typeof Comment.getMultiple;
    /** {@inheritDoc Event.getMultiple} @group Event Functions */
    readonly getEvents: typeof Event.getMultiple;
    /** {@inheritDoc Forum.Topic.create} @group Forum Functions */
    readonly createForumTopic: typeof Forum.Topic.create;
    /** {@inheritDoc Forum.Topic.reply} @group Forum Functions */
    readonly replyForumTopic: typeof Forum.Topic.reply;
    /** {@inheritDoc Forum.Topic.editTitle} @group Forum Functions */
    readonly editForumTopicTitle: typeof Forum.Topic.editTitle;
    /** {@inheritDoc Forum.Post.edit} @group Forum Functions */
    readonly editForumPost: typeof Forum.Post.edit;
    /** {@inheritDoc Forum.getTopicAndPosts} @group Forum Functions */
    readonly getForumTopicAndPosts: typeof Forum.getTopicAndPosts;
    /** {@inheritDoc Home.Search.getUsers} @group Home Functions */
    readonly searchUser: typeof Home.Search.getUsers;
    /** {@inheritDoc Home.Search.getWikiPages} @group Home Functions */
    readonly searchWiki: typeof Home.Search.getWikiPages;
    /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
    readonly getRoom: typeof Multiplayer.Room.getOne;
    /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
    readonly getRooms: typeof Multiplayer.Room.getMultiple;
    /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
    readonly getRoomLeaderboard: typeof Multiplayer.Room.Leader.getMultiple;
    /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
    readonly getPlaylistItemScores: typeof Multiplayer.Room.PlaylistItem.getScores;
    /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
    readonly getMatch: typeof Multiplayer.Match.getOne;
    /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
    readonly getMatches: typeof Multiplayer.Match.getMultiple;
    /** {@inheritDoc NewsPost.getOne} @group NewsPost Functions */
    readonly getNewsPost: typeof NewsPost.getOne;
    /** {@inheritDoc NewsPost.getMultiple} @group NewsPost Functions */
    readonly getNewsPosts: typeof NewsPost.getMultiple;
    /** {@inheritDoc Ranking.getUser} @group Ranking Functions */
    readonly getUserRanking: typeof Ranking.getUser;
    /** {@inheritDoc Ranking.getCountry} @group Ranking Functions */
    readonly getCountryRanking: typeof Ranking.getCountry;
    /** {@inheritDoc Ranking.getKudosu} @group Ranking Functions */
    readonly getKudosuRanking: typeof Ranking.getKudosu;
    /** {@inheritDoc Ranking.getSpotlight} @group Ranking Functions */
    readonly getSpotlightRanking: typeof Ranking.getSpotlight;
    /** {@inheritDoc User.getResourceOwner} @group User Functions */
    readonly getResourceOwner: typeof User.getResourceOwner;
    /** {@inheritDoc User.getOne} @group User Functions */
    readonly getUser: typeof User.getOne;
    /** {@inheritDoc User.getMultiple} @group User Functions */
    readonly getUsers: typeof User.getMultiple;
    /** {@inheritDoc User.getScores} @group User Functions */
    readonly getUserScores: typeof User.getScores;
    /** {@inheritDoc User.getBeatmaps} @group User Functions */
    readonly getUserBeatmaps: typeof User.getBeatmaps;
    /** {@inheritDoc User.getMostPlayed} @group User Functions */
    readonly getUserMostPlayed: typeof User.getMostPlayed;
    /** {@inheritDoc User.getRecentActivity} @group User Functions */
    readonly getUserRecentActivity: typeof User.getRecentActivity;
    /** {@inheritDoc User.getKudosu} @group User Functions */
    readonly getUserKudosu: typeof User.getKudosu;
    /** {@inheritDoc User.getFriends} @group User Functions */
    readonly getFriends: typeof User.getFriends;
    /** {@inheritDoc WikiPage.getOne} @group WikiPage Functions */
    readonly getWikiPage: typeof WikiPage.getOne;
    /** {@inheritDoc Spotlight.getAll} @group Other Functions */
    readonly getSpotlights: typeof Spotlight.getAll;
    /** {@inheritDoc Score.getReplay} @group Other Functions */
    readonly getReplay: typeof Score.getReplay;
    /**
     * Get the backgrounds made and selected for this season or for last season!
     * @returns When the season ended, and for each background, its URL and its artist
     * @group Other Functions
     */
    getSeasonalBackgrounds(): Promise<{
        ends_at: Date;
        backgrounds: {
            url: string;
            user: User;
        }[];
    }>;
}
/**
 * Created with {@link API.withSettings}, this special version of the {@link API} specifies additional settings to every request!
 * @remarks This **is not** to be used for any purpose other than calling methods; The original {@link ChildAPI.original} handles tokens & configuration
 */
export declare class ChildAPI extends API {
    /** The {@link API} where {@link API.withSettings} was used; this `ChildAPI` gets everything from it! */
    original: API;
    /** The additional settings that are used for every request made by this object */
    additional_fetch_settings: Omit<RequestInit, "body">;
    request: (method: "get" | "post" | "put" | "delete", endpoint: string, parameters?: {
        [k: string]: any;
    } | undefined, settings?: Omit<RequestInit, "body"> | undefined, info?: {
        number_try: number;
        just_refreshed: boolean;
    } | undefined) => Promise<any>;
    /** @hidden @deprecated use API equivalent */
    get access_token(): string;
    /** @hidden @deprecated use API equivalent */
    get client(): {
        id: number;
        secret: string;
    };
    /** @hidden @deprecated use API equivalent */
    get expires(): Date;
    /** @hidden @deprecated use API equivalent */
    get refresh_on_401(): boolean;
    /** @hidden @deprecated use API equivalent */
    get refresh_on_expires(): boolean;
    /** @hidden @deprecated use API equivalent */
    get refresh_timeout(): NodeJS.Timeout | undefined;
    /** @hidden @deprecated use API equivalent */
    get refresh_token(): string | undefined;
    /** @hidden @deprecated use API equivalent */
    get retry(): {
        /** If true, doesn't retry under any circumstances (defaults to **false**) */
        disabled: boolean;
        /** In seconds, how long should it wait until retrying? (defaults to **2**) */
        delay: number;
        /** How many retries maximum before throwing an {@link APIError} (defaults to **5**) */
        maximum_amount: number;
        /** Should it retry a request upon successfully refreshing the token due to {@link API.refresh_on_401} being `true`? (defaults to **true**) */
        on_automatic_refresh: boolean;
        /** Should it retry a request if that request failed because it has been aborted by the {@link API.timeout}? (defaults to **false**) */
        on_timeout: boolean;
        /** Upon failing a request and receiving a response, because of which received status code should the request be retried? (defaults to **[429]**) */
        on_status_codes: number[];
    };
    /** @hidden @deprecated use API equivalent */
    get scopes(): Scope[] | undefined;
    /** @hidden @deprecated use API equivalent */
    get server(): string;
    /** @hidden @deprecated use API equivalent */
    get timeout(): number;
    /** @hidden @deprecated use API equivalent */
    get token_type(): string;
    /** @hidden @deprecated use API equivalent */
    get user(): number | undefined;
    /** @hidden @deprecated use API equivalent */
    get verbose(): "all" | "none" | "errors" | undefined;
    /** @hidden @deprecated use API equivalent */
    generateWebSocket: () => WebSocket;
    /** @hidden @deprecated use API equivalent */
    refreshToken: () => Promise<boolean>;
    /** @hidden @deprecated use API equivalent */
    revokeToken: () => Promise<true>;
    /** @hidden @deprecated use API equivalent */
    withSettings: (additional_fetch_settings: Omit<RequestInit, "body">) => ChildAPI;
    constructor(original: ChildAPI["original"], additional_fetch_settings: ChildAPI["additional_fetch_settings"]);
}
