var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fetch from "node-fetch";
import { WebSocket } from "ws";
import { User } from "./user.js";
import { Beatmap } from "./beatmap.js";
import { Beatmapset } from "./beatmapset.js";
import { Multiplayer } from "./multiplayer.js";
import { Score } from "./score.js";
import { Ranking } from "./ranking.js";
import { Event } from "./event.js";
import { Changelog } from "./changelog.js";
import { Forum } from "./forum.js";
import { WikiPage } from "./wiki.js";
import { NewsPost } from "./news.js";
import { Home } from "./home.js";
import { Spotlight, adaptParametersForGETRequests, anySignal, correctType } from "./misc.js";
import { Chat } from "./chat.js";
import { Comment } from "./comment.js";
export { User } from "./user.js";
export { Beatmap } from "./beatmap.js";
export { Beatmapset } from "./beatmapset.js";
export { Multiplayer } from "./multiplayer.js";
export { Score } from "./score.js";
export { Ranking } from "./ranking.js";
export { Event } from "./event.js";
export { Changelog } from "./changelog.js";
export { Forum } from "./forum.js";
export { WikiPage } from "./wiki.js";
export { NewsPost } from "./news.js";
export { Home } from "./home.js";
export { Ruleset, Spotlight } from "./misc.js";
export { Chat } from "./chat.js";
export { WebSocket } from "./websocket.js";
export { Comment } from "./comment.js";
/**
 * Generates a link for users to click on in order to use your application!
 * @param client_id The Client ID, find it at https://osu.ppy.sh/home/account/edit#new-oauth-application
 * @param redirect_uri The specified Application Callback URL, aka where the user will be redirected upon clicking the button to authorize
 * @param scopes What you want to do with/as the user
 * @param server The API server (defaults to **https://osu.ppy.sh**, leave as is if you don't know exactly what you're doing)
 * @returns The link people should click on
 */
export function generateAuthorizationURL(client_id, redirect_uri, scopes, server = "https://osu.ppy.sh") {
    const s = String(scopes).replace(/,/g, "%20");
    return `${server}/oauth/authorize?client_id=${client_id}&redirect_uri=${redirect_uri}&scope=${s}&response_type=code`;
}
/** If the {@link API} throws an error, it should always be an {@link APIError}! */
export class APIError {
    constructor(message, server, method, endpoint, parameters, status_code, original_error) {
        this.message = message;
        this.server = server;
        this.method = method;
        this.endpoint = endpoint;
        this.parameters = parameters;
        this.status_code = status_code;
        this.original_error = original_error;
    }
}
/** You can create an API instance without directly providing an access_token by using {@link API.createAsync}! */
export class API {
    /** The key that allows you to talk with the API */
    get access_token() { return this._access_token; }
    set access_token(token) { this._access_token = token; }
    /** Should always be "Bearer" */
    get token_type() { return this._token_type; }
    set token_type(token) { this._token_type = token; }
    /** The expiration date of your access_token */
    get expires() { return this._expires; }
    set expires(date) {
        this._expires = date;
        this.updateRefreshTimeout();
    }
    /**
     * Valid for an unknown amount of time, allows you to get a new token without going through the Authorization Code Grant again!
     * Use {@link API.refreshToken} to do that
     */
    get refresh_token() { return this._refresh_token; }
    set refresh_token(token) {
        this._refresh_token = token;
        this.updateRefreshTimeout(); // because the refresh token may be specified last
    }
    /** If true, upon failing a request due to a 401, it will use the {@link API.refresh_token} if it exists (defaults to **true**) */
    get refresh_on_401() { return this._refresh_on_401; }
    set refresh_on_401(refresh) { this._refresh_on_401 = refresh; }
    /**
     * If true, the application will silently use the {@link API.refresh_token} right before the {@link API.access_token} expires,
     * as determined by {@link API.expires} (defaults to **true**)
     */
    get refresh_on_expires() { return this._refresh_on_expires; }
    set refresh_on_expires(enabled) {
        this._refresh_on_expires = enabled;
        this.updateRefreshTimeout();
    }
    get refresh_timeout() { return this._refresh_timeout; }
    set refresh_timeout(timeout) {
        // if a previous one already exists, clear it
        if (this._refresh_timeout) {
            clearTimeout(this._refresh_timeout);
        }
        this._refresh_timeout = timeout;
        this._refresh_timeout.unref(); // don't prevent exiting the program while this timeout is going on
    }
    /** The details of your client, which you've got from https://osu.ppy.sh/home/account/edit#oauth */
    get client() { return this._client; }
    set client(client) { this._client = client; }
    /**
     * The base url of the server where the requests should land (defaults to **https://osu.ppy.sh**)
     * @remarks For tokens, requests will be sent to the `oauth/token` route, other requests will be sent to the `api/v2` route
     */
    get server() { return this._server; }
    set server(server) { this._server = server; }
    /** The osu! user id of the user who went through the Authorization Code Grant */
    get user() { return this._user; }
    set user(user) { this._user = user; }
    /** The {@link Scope}s your application has, assuming it acts as a user */
    get scopes() { return this._scopes; }
    set scopes(scopes) { this._scopes = scopes; }
    /** Which events should be logged (defaults to **none**) */
    get verbose() { return this._verbose; }
    set verbose(verbose) { this._verbose = verbose; }
    /**
     * The maximum **amount of seconds** requests should take before returning an answer (defaults to **20**)
     * @remarks 0 means no maximum, no timeout
     */
    get timeout() { return this._timeout; }
    set timeout(timeout) { this._timeout = timeout; }
    /** Configure how this instance should behave when it comes to automatically retrying a request */
    get retry() { return this._retry; }
    set retry(retry) { this._retry = retry; }
    /**
     * **Please use {@link API.createAsync} instead of the default constructor** if you don't have at least an {@link API.access_token}!
     * An API object without an `access_token` is pretty much useless!
     */
    constructor(properties) {
        // ACCESS TOKEN STUFF
        this._access_token = "";
        this._token_type = "Bearer";
        this._expires = new Date(new Date().getTime() + 24 * 60 * 60 * 1000); // in 24 hours
        this._refresh_on_401 = true;
        this._refresh_on_expires = true;
        // CLIENT INFO
        this._client = { id: 0, secret: "" };
        this._server = "https://osu.ppy.sh";
        // CLIENT CONFIGURATION
        this._verbose = "none";
        this._timeout = 20;
        this._retry = {
            disabled: false,
            delay: 2,
            maximum_amount: 5,
            on_automatic_refresh: true,
            on_timeout: false,
            on_status_codes: [429]
        };
        // BEATMAP STUFF
        /** {@inheritDoc Beatmap.lookup} @group Beatmap Functions */
        this.lookupBeatmap = Beatmap.lookup;
        /** {@inheritDoc Beatmap.getOne} @group Beatmap Functions */
        this.getBeatmap = Beatmap.getOne;
        /** {@inheritDoc Beatmap.getMultiple} @group Beatmap Functions */
        this.getBeatmaps = Beatmap.getMultiple;
        /** {@inheritDoc Beatmap.DifficultyAttributes.get} @group Beatmap Functions */
        this.getBeatmapDifficultyAttributes = Beatmap.DifficultyAttributes.get;
        /** {@inheritDoc Beatmap.DifficultyAttributes.getOsu} @group Beatmap Functions */
        this.getBeatmapDifficultyAttributesOsu = Beatmap.DifficultyAttributes.getOsu;
        /** {@inheritDoc Beatmap.DifficultyAttributes.getTaiko} @group Beatmap Functions */
        this.getBeatmapDifficultyAttributesTaiko = Beatmap.DifficultyAttributes.getTaiko;
        /** {@inheritDoc Beatmap.DifficultyAttributes.getFruits} @group Beatmap Functions */
        this.getBeatmapDifficultyAttributesFruits = Beatmap.DifficultyAttributes.getFruits;
        /** {@inheritDoc Beatmap.DifficultyAttributes.getMania} @group Beatmap Functions */
        this.getBeatmapDifficultyAttributesMania = Beatmap.DifficultyAttributes.getMania;
        /** {@inheritDoc Beatmap.Pack.getOne} @group Beatmap Functions */
        this.getBeatmapPack = Beatmap.Pack.getOne;
        /** {@inheritDoc Beatmap.Pack.getMultiple} @group Beatmap Functions */
        this.getBeatmapPacks = Beatmap.Pack.getMultiple;
        /** {@inheritDoc Beatmap.getScores} @group Beatmap Functions */
        this.getBeatmapScores = Beatmap.getScores;
        /** {@inheritDoc Beatmap.getSoloScores} @group Beatmap Functions */
        this.getBeatmapSoloScores = Beatmap.getSoloScores;
        /** {@inheritDoc Beatmap.UserScore.getOne} @group Beatmap Functions */
        this.getBeatmapUserScore = Beatmap.UserScore.getOne;
        /** {@inheritDoc Beatmap.UserScore.getMultiple} @group Beatmap Functions */
        this.getBeatmapUserScores = Beatmap.UserScore.getMultiple;
        // BEATMAPSET STUFF
        /** {@inheritDoc Beatmapset.search} @group Beatmapset Functions */
        this.searchBeatmapsets = Beatmapset.search;
        /** {@inheritDoc Beatmapset.lookup} @group Beatmapset Functions */
        this.lookupBeatmapset = Beatmapset.lookup;
        /** {@inheritDoc Beatmapset.getOne} @group Beatmapset Functions */
        this.getBeatmapset = Beatmapset.getOne;
        /** {@inheritDoc Beatmapset.Discussion.getMultiple} @group Beatmapset Functions */
        this.getBeatmapsetDiscussions = Beatmapset.Discussion.getMultiple;
        /** {@inheritDoc Beatmapset.Discussion.Post.getMultiple} @group Beatmapset Functions */
        this.getBeatmapsetDiscussionPosts = Beatmapset.Discussion.Post.getMultiple;
        /** {@inheritDoc Beatmapset.Discussion.Vote.getMultiple} @group Beatmapset Functions */
        this.getBeatmapsetDiscussionVotes = Beatmapset.Discussion.Vote.getMultiple;
        /** {@inheritDoc Beatmapset.Event.getMultiple} @group Beatmapset Functions */
        this.getBeatmapsetEvents = Beatmapset.Event.getMultiple;
        // CHANGELOG STUFF
        /** {@inheritDoc Changelog.Build.lookup} @group Changelog Functions */
        this.lookupChangelogBuild = Changelog.Build.lookup;
        /** {@inheritDoc Changelog.Build.getOne} @group Changelog Functions */
        this.getChangelogBuild = Changelog.Build.getOne;
        /** {@inheritDoc Changelog.Build.getMultiple} @group Changelog Functions */
        this.getChangelogBuilds = Changelog.Build.getMultiple;
        /** {@inheritDoc Changelog.UpdateStream.getAll} @group Changelog Functions */
        this.getChangelogStreams = Changelog.UpdateStream.getAll;
        // CHAT STUFF
        /** {@inheritDoc Chat.keepAlive} @group Chat Functions */
        this.keepChatAlive = Chat.keepAlive;
        /** {@inheritDoc Chat.Message.getMultiple} @group Chat Functions */
        this.getChatMessages = Chat.Message.getMultiple;
        /** {@inheritDoc Chat.Message.send} @group Chat Functions */
        this.sendChatMessage = Chat.Message.send;
        /** {@inheritDoc Chat.Message.sendPrivate} @group Chat Functions */
        this.sendChatPrivateMessage = Chat.Message.sendPrivate;
        /** {@inheritDoc Chat.Channel.getOne} @group Chat Functions */
        this.getChatChannel = Chat.Channel.getOne;
        /** {@inheritDoc Chat.Channel.getAll} @group Chat Functions */
        this.getChatChannels = Chat.Channel.getAll;
        /** {@inheritDoc Chat.Channel.markAsRead} @group Chat Functions */
        this.markChatChannelAsRead = Chat.Channel.markAsRead;
        /** {@inheritDoc Chat.Channel.createPrivate} @group Chat Functions */
        this.createChatPrivateChannel = Chat.Channel.createPrivate;
        /** {@inheritDoc Chat.Channel.createAnnouncement} @group Chat Functions */
        this.createChatAnnouncementChannel = Chat.Channel.createAnnouncement;
        /** {@inheritDoc Chat.Channel.joinOne} @group Chat Functions */
        this.joinChatChannel = Chat.Channel.joinOne;
        /** {@inheritDoc Chat.Channel.leaveOne} @group Chat Functions */
        this.leaveChatChannel = Chat.Channel.leaveOne;
        // COMMENT STUFF
        /** {@inheritDoc Comment.getOne} @group Comment Functions */
        this.getComment = Comment.getOne;
        /** {@inheritDoc Comment.getMultiple} @group Comment Functions */
        this.getComments = Comment.getMultiple;
        // EVENT STUFF
        /** {@inheritDoc Event.getMultiple} @group Event Functions */
        this.getEvents = Event.getMultiple;
        // FORUM STUFF
        /** {@inheritDoc Forum.Topic.create} @group Forum Functions */
        this.createForumTopic = Forum.Topic.create;
        /** {@inheritDoc Forum.Topic.reply} @group Forum Functions */
        this.replyForumTopic = Forum.Topic.reply;
        /** {@inheritDoc Forum.Topic.editTitle} @group Forum Functions */
        this.editForumTopicTitle = Forum.Topic.editTitle;
        /** {@inheritDoc Forum.Post.edit} @group Forum Functions */
        this.editForumPost = Forum.Post.edit;
        /** {@inheritDoc Forum.getTopicAndPosts} @group Forum Functions */
        this.getForumTopicAndPosts = Forum.getTopicAndPosts;
        // HOME STUFF
        /** {@inheritDoc Home.Search.getUsers} @group Home Functions */
        this.searchUser = Home.Search.getUsers;
        /** {@inheritDoc Home.Search.getWikiPages} @group Home Functions */
        this.searchWiki = Home.Search.getWikiPages;
        // MULTIPLAYER STUFF
        /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
        this.getRoom = Multiplayer.Room.getOne;
        /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
        this.getRooms = Multiplayer.Room.getMultiple;
        /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
        this.getRoomLeaderboard = Multiplayer.Room.Leader.getMultiple;
        /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
        this.getPlaylistItemScores = Multiplayer.Room.PlaylistItem.getScores;
        /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
        this.getMatch = Multiplayer.Match.getOne;
        /** {@inheritDoc Multiplayer.Room.getOne} @group Multiplayer Functions */
        this.getMatches = Multiplayer.Match.getMultiple;
        // NEWS STUFF
        /** {@inheritDoc NewsPost.getOne} @group NewsPost Functions */
        this.getNewsPost = NewsPost.getOne;
        /** {@inheritDoc NewsPost.getMultiple} @group NewsPost Functions */
        this.getNewsPosts = NewsPost.getMultiple;
        // RANKING STUFF
        /** {@inheritDoc Ranking.getUser} @group Ranking Functions */
        this.getUserRanking = Ranking.getUser;
        /** {@inheritDoc Ranking.getCountry} @group Ranking Functions */
        this.getCountryRanking = Ranking.getCountry;
        /** {@inheritDoc Ranking.getKudosu} @group Ranking Functions */
        this.getKudosuRanking = Ranking.getKudosu;
        /** {@inheritDoc Ranking.getSpotlight} @group Ranking Functions */
        this.getSpotlightRanking = Ranking.getSpotlight;
        // USER STUFF
        /** {@inheritDoc User.getResourceOwner} @group User Functions */
        this.getResourceOwner = User.getResourceOwner;
        /** {@inheritDoc User.getOne} @group User Functions */
        this.getUser = User.getOne;
        /** {@inheritDoc User.getMultiple} @group User Functions */
        this.getUsers = User.getMultiple;
        /** {@inheritDoc User.getScores} @group User Functions */
        this.getUserScores = User.getScores;
        /** {@inheritDoc User.getBeatmaps} @group User Functions */
        this.getUserBeatmaps = User.getBeatmaps;
        /** {@inheritDoc User.getMostPlayed} @group User Functions */
        this.getUserMostPlayed = User.getMostPlayed;
        /** {@inheritDoc User.getRecentActivity} @group User Functions */
        this.getUserRecentActivity = User.getRecentActivity;
        /** {@inheritDoc User.getKudosu} @group User Functions */
        this.getUserKudosu = User.getKudosu;
        /** {@inheritDoc User.getFriends} @group User Functions */
        this.getFriends = User.getFriends;
        // WIKI STUFF
        /** {@inheritDoc WikiPage.getOne} @group WikiPage Functions */
        this.getWikiPage = WikiPage.getOne;
        // OTHER STUFF
        /** {@inheritDoc Spotlight.getAll} @group Other Functions */
        this.getSpotlights = Spotlight.getAll;
        /** {@inheritDoc Score.getReplay} @group Other Functions */
        this.getReplay = Score.getReplay;
        // delete every property that is `undefined` so the class defaults aren't overwritten by `undefined`
        // for example, someone using `createAsync()` is extremely likely to leave `server` as `undefined`, which would call the constructor with that
        Object.keys(properties).forEach(key => properties[key] === undefined ? delete properties[key] : {});
        Object.assign(this, properties);
    }
    /**
     * The normal way to create an API instance! Make sure to `await` it
     * @param client The ID and the secret of your client, can be found on https://osu.ppy.sh/home/account/edit#new-oauth-application
     * @param user If the instance is supposed to represent a user, use their Authorization Code and the Application Callback URL of your application!
     * @returns A promise with an API instance
     */
    static createAsync(client, user, verbose, server, 
    /** @remarks In **seconds** */
    timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const new_api = new API({
                client,
                verbose,
                server,
                timeout
            });
            return user ?
                yield new_api.getAndSetToken({ client_id: client.id, client_secret: client.secret, grant_type: "authorization_code",
                    redirect_uri: user.redirect_uri, code: user.code }, new_api) :
                yield new_api.getAndSetToken({ client_id: client.id, client_secret: client.secret, grant_type: "client_credentials", scope: "public" }, new_api);
        });
    }
    /**
     * You can use this to specify additional settings for the method you're going to call, such as `headers`, an `AbortSignal`, and more advanced things!
     * @example
     * ```ts
     * const controller = new AbortController() // this controller can be used to abort any request that uses its signal!
     * const user = await api.withSettings({signal: controller.signal}).getUser(7276846)
     * ```
     * @param additional_fetch_settings You may get more info at https://www.npmjs.com/package/node-fetch#fetch-options
     * @returns A special version of the `API` that changes how requests are done
     */
    withSettings(additional_fetch_settings) {
        return new ChildAPI(this, additional_fetch_settings);
    }
    /**
     * Get a websocket to get WebSocket events from!
     * @param server Where the "notification websocket/server" is
     * (defaults to **the {@link API.server}'s protocol and a maximum of 1 subdomain being replaced by "wss://notify."** (so usually `wss://notify.ppy.sh`))
    */
    generateWebSocket(server = `${this.server.replace(/^\w*:\/\/(?:[A-Za-z0-9]+[.](?=[A-Za-z0-9]+[.]([A-Za-z0-9]+)$))?/g, "wss://notify.")}`) {
        return new WebSocket(server, [], {
            headers: {
                "User-Agent": "osu-api-v2-js (https://github.com/TTTaevas/osu-api-v2-js)",
                "Authorization": `${this.token_type} ${this.access_token}`
            }
        });
    }
    /**
     * Use this instead of `console.log` to log any information
     * @param is_error Is the logging happening because of an error?
     * @param to_log Whatever you would put between the parentheses of `console.log()`
     */
    log(is_error, ...to_log) {
        if (this.verbose === "all" || (this.verbose === "errors" && is_error === true)) {
            console.log("osu!api v2 ->", ...to_log);
        }
    }
    /** Add, remove, change the timeout used for refreshing the token automatically whenever certain properties change */
    updateRefreshTimeout() {
        if (this.refresh_token && this.expires && this.refresh_on_expires) {
            const now = new Date();
            const ms = this.expires.getTime() - now.getTime();
            // Let's say that we used a refresh token *after* the expiration time, our refresh token would naturally get updated
            // However, if it is updated before the (local) expiration date is updated, then ms should be 0
            // This should mean that, upon using a refresh token, we would use our new refresh token instantly...
            // In other words, don't allow timeouts that would mean no timeout; refreshToken() exists for that
            if (ms <= 0) {
                return undefined;
            }
            this.refresh_timeout = setTimeout(() => {
                try {
                    this.refreshToken();
                }
                catch (_a) { }
            }, ms);
        }
        else if (this._refresh_timeout) {
            clearTimeout(this._refresh_timeout);
        }
    }
    getAndSetToken(body, api) {
        return __awaiter(this, void 0, void 0, function* () {
            const controller = new AbortController();
            const timer = this.timeout > 0 ? setTimeout(() => {
                controller.abort(`The request wasn't made in time (took more than ${this.timeout} seconds)`);
            }, this.timeout * 1000) : false;
            const response = yield fetch(`${this.server}/oauth/token`, {
                method: "post",
                headers: {
                    "Accept": "application/json",
                    "Content-Type": "application/json",
                    "User-Agent": "osu-api-v2-js (https://github.com/TTTaevas/osu-api-v2-js)"
                },
                body: JSON.stringify(body),
                signal: controller.signal
            })
                .catch((e) => {
                throw new APIError("Failed to fetch a token", this.server, "post", "oauth/token", body, undefined, e);
            })
                .finally(() => {
                if (timer) {
                    clearTimeout(timer);
                }
            });
            const json = yield response.json();
            if (!json.access_token) {
                this.log(true, "Unable to obtain a token! Here's what was received from the API:", json);
                throw new APIError("No token obtained", this.server, "post", "oauth/token", body, response.status);
            }
            api.token_type = json.token_type;
            if (json.refresh_token) {
                api.refresh_token = json.refresh_token;
            }
            const token = json.access_token;
            api.access_token = token;
            const token_payload = JSON.parse(Buffer.from(token.substring(token.indexOf(".") + 1, token.lastIndexOf(".")), "base64").toString('ascii'));
            api.scopes = token_payload.scopes;
            if (token_payload.sub && token_payload.sub.length) {
                api.user = Number(token_payload.sub);
            }
            const expiration_date = new Date();
            expiration_date.setSeconds(expiration_date.getSeconds() + json.expires_in);
            api.expires = expiration_date;
            return api;
        });
    }
    /** @returns Whether or not the token has been refreshed */
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.refresh_token) {
                this.log(true, "Ignored an attempt at refreshing the access token despite not having a refresh token!");
                return false;
            }
            const old_token = this.access_token;
            try {
                yield this.getAndSetToken({ client_id: this.client.id, client_secret: this.client.secret, grant_type: "refresh_token", refresh_token: this.refresh_token }, this);
                if (old_token !== this.access_token) {
                    this.log(false, "The token has been refreshed!");
                }
            }
            catch (e) {
                this.log(true, "Failed to refresh the token :(", e);
            }
            return old_token !== this.access_token;
        });
    }
    /** Revoke your current token! Revokes the refresh token as well */
    revokeToken() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.request("delete", "oauth/tokens/current");
            return true;
        });
    }
    /**
     * The function that directly communicates with the API! Almost every functions of the API object uses this function!
     * @param method The type of request, each endpoint uses a specific one (if it uses multiple, the intent and parameters become different)
     * @param endpoint What comes in the URL after `api/`
     * @param parameters The things to specify in the request, such as the beatmap_id when looking for a beatmap
     * @param settings Additional settings **to add** to the current settings of the `fetch()` request
     * @param info Context given by a prior request
     * @returns A Promise with the API's response
     */
    request(method, endpoint, parameters = {}, settings, info = { number_try: 1, just_refreshed: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            let to_retry = false;
            let error_object;
            let error_code;
            let error_string = "none";
            const timeout_controller = new AbortController();
            const timeout_signal = timeout_controller.signal;
            const timeout_timer = this.timeout > 0 ? setTimeout(() => {
                if (this.retry.on_timeout) {
                    to_retry = true;
                }
                timeout_controller.abort(`The request wasn't made in time (took more than ${this.timeout} seconds)`);
            }, this.timeout * 1000) : false;
            const signal = (settings === null || settings === void 0 ? void 0 : settings.signal) ? anySignal([timeout_signal, settings.signal]) : timeout_signal;
            // For GET requests specifically, requests need to be shaped in very particular ways
            if (parameters !== undefined && method === "get") {
                parameters = adaptParametersForGETRequests(parameters);
            }
            // parameters are here if request is GET
            const url = `${this.server}/api/v2/${endpoint}` + (method === "get" ? "?" + (Object.entries(parameters).map((param) => {
                if (!Array.isArray(param[1])) {
                    return `${param[0]}=${param[1]}`;
                }
                return param[1].map((array_element) => `${param[0]}=${array_element}`).join("&");
            }).join("&")) : "");
            const response = yield fetch(url, Object.assign(Object.assign({ method }, settings), { headers: Object.assign({ "Accept": "application/json", "Accept-Encoding": "gzip", "Content-Type": "application/json", "User-Agent": "osu-api-v2-js (https://github.com/TTTaevas/osu-api-v2-js)", "Authorization": `${this.token_type} ${this.access_token}` }, settings === null || settings === void 0 ? void 0 : settings.headers // written that way, custom headers with (for example) only a user-agent would only overwrite the default user-agent
                ), body: method !== "get" ? JSON.stringify(parameters) : undefined, // parameters are here if request is NOT GET
                signal }))
                .catch((error) => {
                this.log(true, error.message);
                error_object = error;
                error_string = `${error.name} (${error.name === "FetchError" ? error.errno : error.type})`;
            })
                .finally(() => {
                if (timeout_timer) {
                    clearTimeout(timeout_timer);
                }
            });
            if (!response || !response.ok) {
                if (response) {
                    error_code = response.status;
                    error_string = response.statusText;
                    if (this.retry.on_status_codes.includes(response.status)) {
                        to_retry = true;
                    }
                    if (response.status === 401) {
                        if (this.refresh_on_401 && this.refresh_token && !info.just_refreshed) {
                            this.log(true, "Server responded with status code 401, your token might have expired, I will attempt to refresh your token...");
                            if ((yield this.refreshToken()) && this.retry.on_automatic_refresh) {
                                to_retry = true;
                                info.just_refreshed = true;
                            }
                        }
                        else {
                            this.log(true, "Server responded with status code 401, maybe you need to do this action as a user?");
                        }
                    }
                    else if (response.status === 403) {
                        this.log(true, "Server responded with status code 403, you may lack the necessary scope for this action!");
                    }
                    else if (response.status === 422) {
                        this.log(true, "Server responded with status code 422, you may be unable to use those parameters together!");
                    }
                    else if (response.status === 429) {
                        this.log(true, "Server responded with status code 429, you're sending too many requests at once and are getting rate-limited!");
                    }
                    else {
                        this.log(true, "Server responded with status:", response.status, response.statusText);
                    }
                }
                /**
                 * Under specific circumstances, we want to retry our request automatically
                 * However, spamming the server during the same second in any of these circumstances would be pointless
                 * So we wait for 1 to 5 seconds to make our request, 5 times maximum
                */
                if (to_retry === true && this.retry.disabled === false && info.number_try < this.retry.maximum_amount) {
                    this.log(true, `Will request again in ${this.retry.delay} seconds...`, `(Try #${info.number_try})`);
                    yield new Promise(res => setTimeout(res, this.retry.delay));
                    return yield this.request(method, endpoint, parameters, settings, { number_try: info.number_try + 1, just_refreshed: info.just_refreshed });
                }
                throw new APIError(error_string, `${this.server}/api/v2`, method, endpoint, parameters, error_code, error_object);
            }
            this.log(false, response.statusText, response.status, { method, endpoint, parameters });
            // 204 means the request worked as intended and did not give us anything, so just return nothing
            if (response.status === 204)
                return undefined;
            const arrBuff = yield response.arrayBuffer();
            const buff = Buffer.from(arrBuff);
            try { // Assume the response is in JSON format as it often is, it'll fail into the catch block if it isn't anyway
                // My thorough testing leads me to believe nothing would change if the encoding was also "binary" here btw
                return correctType(JSON.parse(buff.toString("utf-8")));
            }
            catch ( // Assume the response is supposed to not be in JSON format so return it as simple text
            _a) { // Assume the response is supposed to not be in JSON format so return it as simple text
                return buff.toString("binary");
            }
        });
    }
    /**
     * Get the backgrounds made and selected for this season or for last season!
     * @returns When the season ended, and for each background, its URL and its artist
     * @group Other Functions
     */
    getSeasonalBackgrounds() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request("get", "seasonal-backgrounds");
        });
    }
}
/**
 * Created with {@link API.withSettings}, this special version of the {@link API} specifies additional settings to every request!
 * @remarks This **is not** to be used for any purpose other than calling methods; The original {@link ChildAPI.original} handles tokens & configuration
 */
export class ChildAPI extends API {
    // Those are first in accessors -> methods order, then in alphabetical order
    // For the sake of decent documentation and autocomplete
    /** @hidden @deprecated use API equivalent */
    get access_token() { return this.original.access_token; }
    /** @hidden @deprecated use API equivalent */
    get client() { return this.original.client; }
    /** @hidden @deprecated use API equivalent */
    get expires() { return this.original.expires; }
    /** @hidden @deprecated use API equivalent */
    get refresh_on_401() { return this.original.refresh_on_401; }
    /** @hidden @deprecated use API equivalent */
    get refresh_on_expires() { return this.original.refresh_on_expires; }
    /** @hidden @deprecated use API equivalent */
    get refresh_timeout() { return this.original.refresh_timeout; }
    /** @hidden @deprecated use API equivalent */
    get refresh_token() { return this.original.refresh_token; }
    /** @hidden @deprecated use API equivalent */
    get retry() { return this.original.retry; }
    /** @hidden @deprecated use API equivalent */
    get scopes() { return this.original.scopes; }
    /** @hidden @deprecated use API equivalent */
    get server() { return this.original.server; }
    /** @hidden @deprecated use API equivalent */
    get timeout() { return this.original.timeout; }
    /** @hidden @deprecated use API equivalent */
    get token_type() { return this.original.token_type; }
    /** @hidden @deprecated use API equivalent */
    get user() { return this.original.user; }
    /** @hidden @deprecated use API equivalent */
    get verbose() { return this.original.verbose; }
    constructor(original, additional_fetch_settings) {
        super({});
        this.request = (...args) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            (_a = args[3]) !== null && _a !== void 0 ? _a : (args[3] = this.additional_fetch_settings); // args[3] is `settings` **for now**
            return yield this.original.request(...args);
        });
        /** @hidden @deprecated use API equivalent */
        this.generateWebSocket = () => { return this.original.generateWebSocket(); };
        /** @hidden @deprecated use API equivalent */
        this.refreshToken = () => __awaiter(this, void 0, void 0, function* () { return yield this.original.refreshToken(); });
        /** @hidden @deprecated use API equivalent */
        this.revokeToken = () => __awaiter(this, void 0, void 0, function* () { return yield this.original.revokeToken(); });
        /** @hidden @deprecated use API equivalent */
        this.withSettings = (...args) => { return this.original.withSettings(...args); };
        this.original = original;
        this.additional_fetch_settings = additional_fetch_settings;
    }
}
