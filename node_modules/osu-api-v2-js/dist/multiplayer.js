var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getId } from "./misc.js";
export var Multiplayer;
(function (Multiplayer) {
    let Room;
    (function (Room) {
        let PlaylistItem;
        (function (PlaylistItem) {
            /**
             * Get the scores on a specific item of a room!
             * @param item An object with the id of the item in question, as well as the id of the room
             * @param limit How many scores maximum? Defaults to 50, the maximum the API will return
             * @param sort Sort by scores, ascending or descending? Defaults to descending
             * @param cursor_string Use a Multiplayer.Scores' `params` and `cursor_string` to get the next page (scores 51 to 100 for example)
             * @remarks (2024-03-04) This may not work for rooms from before March 5th 2024, use at your own risk
             * https://github.com/ppy/osu-web/issues/10725
             */
            function getScores(item, limit = 50, sort = "score_desc", cursor_string) {
                return __awaiter(this, void 0, void 0, function* () {
                    return yield this.request("get", `rooms/${item.room_id}/playlist/${item.id}/scores`, { limit, sort, cursor_string });
                });
            }
            PlaylistItem.getScores = getScores;
        })(PlaylistItem = Room.PlaylistItem || (Room.PlaylistItem = {}));
        let Leader;
        (function (Leader) {
            /**
             * Get the room stats of all the users of that room!
             * @scope {@link Scope"public"}
             * @param room The room or the id of the room in question
             * @returns An object with the leaderboard, and the score and position of the authorized user under `user_score`
             */
            function getMultiple(room) {
                return __awaiter(this, void 0, void 0, function* () {
                    return yield this.request("get", `rooms/${getId(room)}/leaderboard`);
                });
            }
            Leader.getMultiple = getMultiple;
        })(Leader = Room.Leader || (Room.Leader = {}));
        /**
         * Get data about a lazer multiplayer room (realtime or playlists)!
         * @param room The room or the id of the room, can be found at the end of its URL (after `/multiplayer/rooms/`)
         */
        function getOne(room) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("get", `rooms/${getId(room)}`);
            });
        }
        Room.getOne = getOne;
        /**
         * Get playlists/realtime rooms that are active, that have ended, that the user participated in, that the user made, or just simply any room!
         * @scope {@link Scope"public"}
         * @param type Whether the multiplayer rooms are in playlist format (like current spotlights) or realtime
         * @param mode The state of the room, or the relation of the authorized user with the room
         * @param limit The maximum amount of rooms to return, defaults to 10
         * @param sort Sort (where most recent is first) by creation date or end date, defaults to the creation date
         */
        function getMultiple(type, mode, limit = 10, sort = "created") {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("get", "rooms", { type_group: type, mode, limit, sort });
            });
        }
        Room.getMultiple = getMultiple;
    })(Room = Multiplayer.Room || (Multiplayer.Room = {}));
    let Match;
    (function (Match) {
        /**
         * Get data of a multiplayer lobby from the stable (non-lazer) client that have URLs with `community/matches` or `mp`
         * @param match The id of a match can be found at the end of its URL
         */
        function getOne(match) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.request("get", `matches/${getId(match)}`);
                // Fix `events[i].game.scores[e].perfect` being a number instead of a boolean
                for (let i = 0; i < response.events.length; i++) {
                    for (let e = 0; e < Number((_a = response.events[i].game) === null || _a === void 0 ? void 0 : _a.scores.length); e++) {
                        response.events[i].game.scores[e].perfect = Boolean(response.events[i].game.scores[e].perfect);
                    }
                }
                return response;
            });
        }
        Match.getOne = getOne;
        /**
         * Get the info about several matches!
         * @param query The id of the first match of the array, and the sorting and size of said array
         */
        function getMultiple(query) {
            return __awaiter(this, void 0, void 0, function* () {
                // `first_match_in_array` is a cool way to use the endpoint's cursor
                const cursor = (query === null || query === void 0 ? void 0 : query.first_match_in_array) ? { match_id: getId(query.first_match_in_array) + ((query === null || query === void 0 ? void 0 : query.sort) === "id_asc" ? -1 : 1) } : undefined;
                const response = yield this.request("get", "matches", { cursor, limit: query === null || query === void 0 ? void 0 : query.limit, sort: query === null || query === void 0 ? void 0 : query.sort });
                return response.matches; // NOT the only property; `params` is useless while `cursor` and `cursor_string` are superseded by `first_match_in_array`
            });
        }
        Match.getMultiple = getMultiple;
    })(Match = Multiplayer.Match || (Multiplayer.Match = {}));
})(Multiplayer || (Multiplayer = {}));
