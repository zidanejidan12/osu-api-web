var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getId } from "./misc.js";
export var Beatmapset;
(function (Beatmapset) {
    let RankStatus;
    (function (RankStatus) {
        RankStatus[RankStatus["Graveyard"] = -2] = "Graveyard";
        RankStatus[RankStatus["Wip"] = -1] = "Wip";
        RankStatus[RankStatus["Pending"] = 0] = "Pending";
        RankStatus[RankStatus["Ranked"] = 1] = "Ranked";
        RankStatus[RankStatus["Approved"] = 2] = "Approved";
        RankStatus[RankStatus["Qualified"] = 3] = "Qualified";
        RankStatus[RankStatus["Loved"] = 4] = "Loved";
    })(RankStatus = Beatmapset.RankStatus || (Beatmapset.RankStatus = {}));
    let Genre;
    (function (Genre) {
        Genre[Genre["Any"] = 0] = "Any";
        Genre[Genre["Unspecified"] = 1] = "Unspecified";
        Genre[Genre["Video Game"] = 2] = "Video Game";
        Genre[Genre["Anime"] = 3] = "Anime";
        Genre[Genre["Rock"] = 4] = "Rock";
        Genre[Genre["Pop"] = 5] = "Pop";
        Genre[Genre["Other"] = 6] = "Other";
        Genre[Genre["Novelty"] = 7] = "Novelty";
        Genre[Genre["Hip Hop"] = 9] = "Hip Hop";
        Genre[Genre["Electronic"] = 10] = "Electronic";
        Genre[Genre["Metal"] = 11] = "Metal";
        Genre[Genre["Classical"] = 12] = "Classical";
        Genre[Genre["Folk"] = 13] = "Folk";
        Genre[Genre["Jazz"] = 14] = "Jazz";
    })(Genre = Beatmapset.Genre || (Beatmapset.Genre = {}));
    let Language;
    (function (Language) {
        Language[Language["Any"] = 0] = "Any";
        Language[Language["Unspecified"] = 1] = "Unspecified";
        Language[Language["English"] = 2] = "English";
        Language[Language["Japanese"] = 3] = "Japanese";
        Language[Language["Chinese"] = 4] = "Chinese";
        Language[Language["Instrumental"] = 5] = "Instrumental";
        Language[Language["Korean"] = 6] = "Korean";
        Language[Language["French"] = 7] = "French";
        Language[Language["German"] = 8] = "German";
        Language[Language["Swedish"] = 9] = "Swedish";
        Language[Language["Spanish"] = 10] = "Spanish";
        Language[Language["Italian"] = 11] = "Italian";
        Language[Language["Russian"] = 12] = "Russian";
        Language[Language["Polish"] = 13] = "Polish";
        Language[Language["Other"] = 14] = "Other";
    })(Language = Beatmapset.Language || (Beatmapset.Language = {}));
    let Event;
    (function (Event) {
        /**
         * Get complex data about the events of a beatmapset and the users involved with them!
         * @param from Which beatmapset, or caused by which user? When?
         * @param types What kinds of events?
         * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
         * @returns Relevant events and users
         * @remarks (2024-03-11) For months now, the API's documentation says the response is likely to change, so beware,
         * and also there's no documentation for this route in the API, so this is only the result of my interpretation of the website's code lol
         */
        function getMultiple(from, types, config) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                const beatmapset = (from === null || from === void 0 ? void 0 : from.beatmapset) ? getId(from.beatmapset) : undefined;
                const user = (from === null || from === void 0 ? void 0 : from.user) ? getId(from.user) : undefined;
                return yield this.request("get", "beatmapsets/events", { beatmapset_id: beatmapset, user, min_date: (_a = from === null || from === void 0 ? void 0 : from.min_date) === null || _a === void 0 ? void 0 : _a.toISOString(),
                    max_date: (_b = from === null || from === void 0 ? void 0 : from.max_date) === null || _b === void 0 ? void 0 : _b.toISOString(), types, sort: config === null || config === void 0 ? void 0 : config.sort, page: config === null || config === void 0 ? void 0 : config.page, limit: config === null || config === void 0 ? void 0 : config.limit, cursor_string: config === null || config === void 0 ? void 0 : config.cursor_string });
            });
        }
        Event.getMultiple = getMultiple;
    })(Event = Beatmapset.Event || (Beatmapset.Event = {}));
    let Discussion;
    (function (Discussion) {
        let Post;
        (function (Post) {
            /**
             * Get complex data about the posts of a beatmapset's discussion or of a user!
             * @param from From where/who are the posts coming from? A specific discussion, a specific user?
             * @param types What kind of posts?
             * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
             * @returns Relevant posts and info about them
             * @remarks (2024-03-11) For months now, the API's documentation says the response is likely to change, so beware
             */
            function getMultiple(from, types, config) {
                return __awaiter(this, void 0, void 0, function* () {
                    const discussion = (from === null || from === void 0 ? void 0 : from.discussion) ? getId(from.discussion) : undefined;
                    const user = (from === null || from === void 0 ? void 0 : from.user) ? getId(from.user) : undefined;
                    return yield this.request("get", "beatmapsets/discussions/posts", { beatmapset_discussion_id: discussion, limit: config === null || config === void 0 ? void 0 : config.limit,
                        page: config === null || config === void 0 ? void 0 : config.page, sort: config === null || config === void 0 ? void 0 : config.sort, types, user, cursor_string: config === null || config === void 0 ? void 0 : config.cursor_string });
                });
            }
            Post.getMultiple = getMultiple;
        })(Post = Discussion.Post || (Discussion.Post = {}));
        let Vote;
        (function (Vote) {
            /**
             * Get complex data about the votes of a beatmapset's discussions or/and received/given by a specific user!
             * @param from The discussion with the votes, the user who voted, the user who's gotten the votes...
             * @param score An upvote (1) or a downvote (-1)
             * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
             * @returns Relevant votes and info about them
             * @remarks (2024-03-11) For months now, the API's documentation says the response is likely to change, so beware
             */
            function getMultiple(from, score, config) {
                return __awaiter(this, void 0, void 0, function* () {
                    const discussion = (from === null || from === void 0 ? void 0 : from.discussion) ? getId(from.discussion) : undefined;
                    const user = (from === null || from === void 0 ? void 0 : from.vote_giver) ? getId(from.vote_giver) : undefined;
                    const receiver = (from === null || from === void 0 ? void 0 : from.vote_receiver) ? getId(from.vote_receiver) : undefined;
                    return yield this.request("get", "beatmapsets/discussions/votes", { beatmapset_discussion_id: discussion, limit: config === null || config === void 0 ? void 0 : config.limit,
                        page: config === null || config === void 0 ? void 0 : config.page, receiver, score, sort: config === null || config === void 0 ? void 0 : config.sort, user, cursor_string: config === null || config === void 0 ? void 0 : config.cursor_string });
                });
            }
            Vote.getMultiple = getMultiple;
        })(Vote = Discussion.Vote || (Discussion.Vote = {}));
        /**
         * Get complex data about the discussion page of any beatmapet that you want!
         * @param from From where/who are the discussions coming from? Maybe only qualified sets?
         * @param filter Should those discussions only be unresolved problems, for example?
         * @param config How many results maximum, how to sort them, which page of those, maybe a cursor_string...
         * @returns Relevant discussions and info about them
         * @remarks (2024-03-11) For months now, the API's documentation says the response is likely to change, so beware
         * @privateRemarks I don't allow setting `beatmap_id` because my testing has led me to believe it does nothing (and is therefore misleading)
         */
        function getMultiple(from, filter, config) {
            return __awaiter(this, void 0, void 0, function* () {
                const beatmapset = (from === null || from === void 0 ? void 0 : from.beatmapset) ? getId(from.beatmapset) : undefined;
                const user = (from === null || from === void 0 ? void 0 : from.user) ? getId(from.user) : undefined;
                return yield this.request("get", "beatmapsets/discussions", { beatmapset_id: beatmapset, beatmapset_status: from === null || from === void 0 ? void 0 : from.status,
                    limit: config === null || config === void 0 ? void 0 : config.limit, message_types: filter === null || filter === void 0 ? void 0 : filter.types, only_unresolved: filter === null || filter === void 0 ? void 0 : filter.only_unresolved, page: config === null || config === void 0 ? void 0 : config.page, sort: config === null || config === void 0 ? void 0 : config.sort,
                    user, cursor_string: config === null || config === void 0 ? void 0 : config.cursor_string });
            });
        }
        Discussion.getMultiple = getMultiple;
    })(Discussion = Beatmapset.Discussion || (Beatmapset.Discussion = {}));
    /**
     * Search for beatmapsets as if you were on the website or on lazer!
     * @param query All the filters and sorting options that you'd normally find on the website or on lazer
     * @returns Relevant Beatmapsets that contain Beatmaps, and a cursor_string to allow you to look for more of the same!
     * @remarks This does not bypass the current osu!supporter requirement for certain filters
     */
    function search(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const sort = (query === null || query === void 0 ? void 0 : query.sort) ? (query.sort.by + "_" + query.sort.in) : undefined;
            const c = (query === null || query === void 0 ? void 0 : query.general) ? query.general.map((general_value) => {
                if (general_value === "Recommended difficulty")
                    return "recommended";
                if (general_value === "Include converted beatmaps")
                    return "converts";
                if (general_value === "Subscribed mappers")
                    return "follows";
                if (general_value === "Spotlighted beatmaps")
                    return "spotlights";
                if (general_value === "Featured Artists")
                    return "featured_artists";
            }).join(".") : undefined;
            const s = (query === null || query === void 0 ? void 0 : query.categories) ? query.categories === "My Maps" ? "mine" : query.categories.toLowerCase() : undefined;
            const nsfw = (query === null || query === void 0 ? void 0 : query.hide_explicit_content) ? false : undefined;
            const e = (query === null || query === void 0 ? void 0 : query.extra) ? query.extra.map((extra_value) => {
                if (extra_value === "must_have_video")
                    return "video";
                if (extra_value === "must_have_storyboard")
                    return "storyboard";
            }).join(".") : undefined;
            const r = (query === null || query === void 0 ? void 0 : query.rank_achieved) ? query.rank_achieved.map((rank_achieved_value) => {
                if (rank_achieved_value === "Silver SS")
                    return "XH";
                if (rank_achieved_value === "SS")
                    return "X";
                if (rank_achieved_value === "Silver S")
                    return "SH";
                return rank_achieved_value;
            }).join("x") : undefined;
            const played = (query === null || query === void 0 ? void 0 : query.played) ? query.played.toLowerCase() : undefined;
            return yield this.request("get", `beatmapsets/search`, { q: query === null || query === void 0 ? void 0 : query.keywords, sort, c, m: query === null || query === void 0 ? void 0 : query.mode, s, nsfw, g: query === null || query === void 0 ? void 0 : query.genre, l: query === null || query === void 0 ? void 0 : query.language, e, r, played, cursor_string: query === null || query === void 0 ? void 0 : query.cursor_string });
        });
    }
    Beatmapset.search = search;
    /**
     * Get extensive data about a beatmapset by using a beatmap!
     * @param beatmap A beatmap from the beatmapset you're looking for
     */
    function lookup(beatmap) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request("get", `beatmapsets/lookup`, { beatmap_id: getId(beatmap) });
        });
    }
    Beatmapset.lookup = lookup;
    /**
     * Get extensive beatmapset data about whichever beatmapset you want!
     * @param beatmapset The beatmapset or the id of the beatmapset you're trying to get
     */
    function getOne(beatmapset) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request("get", `beatmapsets/${getId(beatmapset)}`);
        });
    }
    Beatmapset.getOne = getOne;
})(Beatmapset || (Beatmapset = {}));
