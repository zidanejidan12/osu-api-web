var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getId } from "./misc.js";
export var Chat;
(function (Chat) {
    let Channel;
    (function (Channel) {
        /**
         * Get a ChatChannel that you have joined, and the users in it if it is a private channel!
         * @scope {@link Scope"chat.read"}
         * @param channel The channel in question
         * @remarks Will 404 if the user has not joined the channel (use `joinChatChannel` for that)
         */
        function getOne(channel) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.request("get", `chat/channels/${getId(channel, "channel_id")}`);
                return response.channel; // NOT the only property; `users` is already provided within `channel` so it is useless
            });
        }
        Channel.getOne = getOne;
        /**
         * Get a list of all publicly joinable channels!
         * @scope {@link Scope"chat.read"}
         */
        function getAll() {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("get", "chat/channels");
            });
        }
        Channel.getAll = getAll;
        /**
         * Mark a certain channel as read up to a given message!
         * @scope {@link Scope"chat.read"}
         * @param channel The channel in question
         * @param message You're marking this and all the messages before it as read!
         */
        function markAsRead(channel, message) {
            return __awaiter(this, void 0, void 0, function* () {
                const channel_id = getId(channel, "channel_id");
                const message_id = getId(message, "message_id");
                return yield this.request("put", `chat/channels/${channel_id}/mark-as-read/${message_id}`, { channel_id, message_id });
            });
        }
        Channel.markAsRead = markAsRead;
        /**
         * Create/Open/Join a private messages chat channel!
         * @scope {@link Scope"chat.read"}
         * @param user_target The other user able to read and send messages in this channel
         * @returns The newly created channel!
         */
        function createPrivate(user_target) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("post", "chat/channels", { type: "PM", target_id: getId(user_target) });
            });
        }
        Channel.createPrivate = createPrivate;
        /**
         * Create a new announcement!
         * @scope {@link Scope"chat.write_manage"}
         * @param channel Details of the channel you're creating
         * @param user_targets The people that will receive your message
         * @param message The message to send with the announcement
         * @returns The newly created channel!
         * @remarks From my understanding, this WILL 403 unless the user is kinda special
         */
        function createAnnouncement(channel, user_targets, message) {
            return __awaiter(this, void 0, void 0, function* () {
                const target_ids = user_targets.map((u) => getId(u));
                return yield this.request("post", "chat/channels", { type: "ANNOUNCE", channel, target_ids, message });
            });
        }
        Channel.createAnnouncement = createAnnouncement;
        /**
         * Join a public or multiplayer ChatChannel, allowing you to interact with it!
         * @scope {@link Scope"chat.write_manage"}
         * @param channel The channel you wanna join
         * @param user The user joining the channel (defaults to the **presumed authorized user** (api.user))
         */
        function joinOne(channel, user) {
            return __awaiter(this, void 0, void 0, function* () {
                const user_id = user ? getId(user) : this.user ? this.user : "";
                return yield this.request("put", `chat/channels/${getId(channel, "channel_id")}/users/${user_id}`);
            });
        }
        Channel.joinOne = joinOne;
        /**
         * Leave/Close a public ChatChannel!
         * @scope {@link Scope"chat.write_manage"}
         * @param channel The channel you wanna leave/close
         * @param user The user leaving/closing the channel (defaults to the **presumed authorized user** (api.user))
         */
        function leaveOne(channel, user) {
            return __awaiter(this, void 0, void 0, function* () {
                const user_id = user ? getId(user) : this.user ? this.user : "";
                return yield this.request("delete", `chat/channels/${getId(channel, "channel_id")}/users/${user_id}`);
            });
        }
        Channel.leaveOne = leaveOne;
    })(Channel = Chat.Channel || (Chat.Channel = {}));
    let Message;
    (function (Message) {
        /**
         * Get the recent messages of a specific ChatChannel!
         * @scope {@link Scope"chat.read"}
         * @param channel The Channel you wanna get the messages from
         * @param limit The maximum amount of messages you want to get, up to 50! (defaults to **20**)
         * @param since Get the messages sent after this message
         * @param until Get the messages sent up to but not including this message
         */
        function getMultiple(channel, limit = 20, since, until) {
            return __awaiter(this, void 0, void 0, function* () {
                since = since ? getId(since, "message_id") : undefined;
                until = until ? getId(until, "message_id") : undefined;
                return yield this.request("get", `chat/channels/${getId(channel, "channel_id")}/messages`, { limit, since, until });
            });
        }
        Message.getMultiple = getMultiple;
        /**
         * Send a message in a ChatChannel!
         * @scope {@link Scope"chat.write"}
         * @param channel The channel in which you want to send your message
         * @param message The message you wanna send
         * @param is_action Is it a command? Like `/me dances` (defaults to **false**)
         * @returns The newly sent ChatMessage!
         */
        function send(channel, message, is_action = false) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("post", `chat/channels/${getId(channel, "channel_id")}/messages`, { message, is_action });
            });
        }
        Message.send = send;
        /**
         * Send a private message to someone!
         * @scope {@link Scope"chat.write"}
         * @param user_target The User you wanna send your message to!
         * @param message The message you wanna send
         * @param is_action Is it a command? Like `/me dances` (defaults to **false**)
         * @param uuid A client-side message identifier
         * @returns The message you sent
         * @remarks You don't need to use `createChatPrivateChannel` before sending a message
         */
        function sendPrivate(user_target, message, is_action = false, uuid) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("post", "chat/new", { target_id: getId(user_target), message, is_action, uuid });
            });
        }
        Message.sendPrivate = sendPrivate;
    })(Message = Chat.Message || (Chat.Message = {}));
    /**
     * Needs to be done periodically to reset chat activity timeout
     * @scope {@link Scope"chat.read"}
     * @param since UserSilences that are before that will not be returned!
     * @returns A list of recent silences
     * @remarks Every 30 seconds is a good idea
     */
    function keepAlive(since) {
        return __awaiter(this, void 0, void 0, function* () {
            const history_since = (since === null || since === void 0 ? void 0 : since.user_silence) ? getId(since.user_silence) : undefined;
            const message_since = (since === null || since === void 0 ? void 0 : since.message) ? getId(since.message, "message_id") : undefined;
            const response = yield this.request("post", "chat/ack", { history_since, since: message_since });
            return response.silences; // It's the only property
        });
    }
    Chat.keepAlive = keepAlive;
})(Chat || (Chat = {}));
