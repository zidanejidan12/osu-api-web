import { API, Beatmap, Beatmapset, Event, Ruleset, Score } from "./index.js";
export interface User {
    avatar_url: string;
    country_code: string;
    default_group: string;
    id: number;
    is_active: boolean;
    is_bot: boolean;
    is_deleted: boolean;
    is_online: boolean;
    is_supporter: boolean;
    last_visit: Date | null;
    pm_friends_only: boolean;
    profile_colour: string | null;
    username: string;
}
export declare namespace User {
    /**
     * An interface to tell the API how the returned Array should be like
     * @group Parameter Object Interfaces
     */
    interface Config {
        /**
         * The maximum amount of elements returned in the array
         * @remarks The server could send less than the limit because it deliberately limits itself; Putting this at 1000 doesn't mean you'll even get close to 200
         */
        limit?: number;
        /** How many elements that would be at the top of the returned array get skipped (while still filling the array up to the limit) */
        offset?: number;
    }
    interface WithKudosu extends User {
        kudosu: {
            available: number;
            total: number;
        };
    }
    interface WithGroups extends User {
        groups: {
            colour: string | null;
            has_listing: boolean;
            has_playmodes: boolean;
            id: number;
            identifier: string;
            is_probationary: boolean;
            name: string;
            playmodes: (keyof typeof Ruleset)[] | null;
            short_name: string;
        }[];
    }
    /** @obtainableFrom {@link API.getMatch} */
    interface WithCountry extends User {
        country: {
            code: string;
            name: string;
        };
    }
    interface WithCountryCover extends WithCountry {
        cover: {
            custom_url: string | null;
            url: string;
            id: number | null;
        };
    }
    /** @obtainableFrom {@link API.getUsers} */
    interface WithCountryCoverGroupsStatisticsrulesets extends WithCountryCover, WithGroups {
        statistics_rulesets: {
            osu?: Statistics;
            taiko?: Statistics;
            fruits?: Statistics;
            mania?: Statistics;
        };
    }
    /** @obtainableFrom {@link API.getFriends} */
    interface WithCountryCoverGroupsStatisticsSupport extends WithCountryCover, WithGroups {
        statistics: Statistics;
        support_level: number;
    }
    /** @obtainableFrom {@link API.getUser} */
    interface Extended extends WithCountryCoverGroupsStatisticsSupport, WithKudosu {
        cover_url: string;
        discord: string | null;
        has_supported: boolean;
        interests: string | null;
        join_date: Date;
        location: string | null;
        max_blocks: number;
        max_friends: number;
        occupation: string | null;
        playmode: keyof typeof Ruleset;
        playstyle: string[] | null;
        post_count: number;
        profile_order: ("me" | "recent_activity" | "beatmaps" | "historical" | "kudosu" | "top_ranks" | "medals")[];
        title: string | null;
        title_url: string | null;
        twitter: string | null;
        website: string | null;
        account_history: {
            description: string | null;
            id: number;
            length: number;
            permanent: boolean;
            timestamp: Date;
            type: "note" | "restriction" | "silence";
        }[];
        active_tournament_banners: {
            id: number;
            tournament_id: number;
            image: string;
        }[];
        badges: {
            awarded_at: Date;
            description: string;
            image_url: string;
            url: string;
        }[];
        beatmap_playcounts_count: number;
        comments_count: number;
        favourite_beatmapset_count: number;
        follower_count: number;
        graveyard_beatmapset_count: number;
        guest_beatmapset_count: number;
        loved_beatmapset_count: number;
        mapping_follower_count: number;
        monthly_playcounts: {
            start_date: Date;
            count: number;
        }[];
        nominated_beatmapset_count: number;
        page: {
            html: string;
            /** Basically the text with the BBCode */
            raw: string;
        };
        pending_beatmapset_count: number;
        previous_usernames: User["username"][];
        rank_highest: {
            rank: number;
            updated_at: Date;
        } | null;
        replays_watched_counts: {
            start_date: Date;
            count: number;
        }[];
        scores_best_count: number;
        scores_first_count: number;
        /** Specific to the Ruleset (`playmode`) */
        scores_pinned_count: number;
        scores_recent_count: number;
        statistics: Statistics.WithCountryrank;
        support_level: number;
        user_achievements: {
            achieved_at: Date;
            achievement_id: number;
        }[];
        rank_history: {
            mode: keyof typeof Ruleset;
            data: number[];
        } | null;
    }
    namespace Extended {
        /** @obtainableFrom {@link API.getResourceOwner} */
        interface WithStatisticsrulesets extends Extended, User.WithCountryCoverGroupsStatisticsrulesets {
            is_restricted: boolean;
        }
    }
    interface Statistics {
        count_300: number;
        count_100: number;
        count_50: number;
        count_miss: number;
        global_rank: number | null;
        global_rank_exp: number | null;
        grade_counts: {
            a: number;
            s: number;
            sh: number;
            ss: number;
            ssh: number;
        };
        /** Accuracy in the normal format, where 96.56% would be `96.56` */
        hit_accuracy: number;
        /** Hasn't become inactive in the rankings */
        is_ranked: boolean;
        level: {
            current: number;
            progress: number;
        };
        maximum_combo: number;
        play_count: number;
        play_time: number | null;
        pp: number | null;
        pp_exp: number;
        ranked_score: number;
        replays_watched_by_others: number;
        total_hits: number;
        total_score: number;
    }
    namespace Statistics {
        interface WithCountryrank extends Statistics {
            country_rank: number | null;
        }
        interface WithUser extends Statistics {
            user: User.WithCountryCover;
        }
    }
    /** @obtainableFrom {@link API.getUserKudosu} */
    interface KudosuHistory {
        id: number;
        action: "give" | "vote.give" | "reset" | "vote.reset" | "revoke" | "vote.revoke";
        amount: number;
        model: string;
        created_at: Date;
        giver: {
            url: string;
            username: string;
        } | null;
        post: {
            url: string | null;
            title: string;
        };
    }
    /**
     * Get extensive user data about the authorized user
     * @scope {@link Scope"identify"}
     * @param ruleset The data should be relevant to which ruleset? (defaults to **user's default Ruleset**)
     */
    function getResourceOwner(this: API, ruleset?: Ruleset): Promise<User.Extended.WithStatisticsrulesets>;
    /**
     * Get extensive user data about whoever you want!
     * @param user A user id, a username or a `User` object!
     * @param ruleset The data should be relevant to which ruleset? (defaults to **user's default Ruleset**)
     */
    function getOne(this: API, user: User["id"] | User["username"] | User, ruleset?: Ruleset): Promise<User.Extended>;
    /**
     * Get user data for up to 50 users at once!
     * @param users An array containing user ids or/and `User` objects!
     */
    function getMultiple(this: API, users: Array<User["id"] | User>): Promise<User.WithCountryCoverGroupsStatisticsrulesets[]>;
    /**
     * Get "notable" scores from a user
     * @param user The user who set the scores
     * @param type Do you want scores: in the user's top 100, that are top 1 on a beatmap, that have been recently set?
     * @param ruleset The Ruleset the scores were made in (defaults to **user's default Ruleset**)
     * @param include Do you also want lazer scores and failed scores? (defaults to **true for lazer** & **false for fails**)
     * @param config Array limit & offset
     */
    function getScores(this: API, user: User["id"] | User, type: "best" | "firsts" | "recent", ruleset?: Ruleset, include?: {
        lazer?: boolean;
        fails?: boolean;
    }, config?: Config): Promise<Score.WithUserBeatmapBeatmapset[]>;
    /**
     * Get beatmaps favourited or made by a user!
     * @param user The user in question
     * @param type The relation between the user and the beatmaps
     * @param config Array limit & offset
     */
    function getBeatmaps(this: API, user: User["id"] | User, type: "favourite" | "graveyard" | "guest" | "loved" | "nominated" | "pending" | "ranked", config?: Config): Promise<Beatmapset.Extended.WithBeatmap[]>;
    /**
     * Get the beatmaps most played by a user!
     * @param user The user who played the beatmaps
     * @param config Array limit & offset
     */
    function getMostPlayed(this: API, user: User["id"] | User, config?: Config): Promise<Beatmap.Playcount[]>;
    /**
     * Get an array of Events of different `type`s that relate to a user's activity during the last 31 days! (or 100 activities, whatever comes first)
     * @param user The user in question
     * @param config Array limit & offset
     */
    function getRecentActivity(this: API, user: User["id"] | User, config?: Config): Promise<Event.AnyRecentActivity[]>;
    /**
     * Get data about the activity of a user kudosu-wise!
     * @param user The user in question
     * @param config Array limit & offset
     */
    function getKudosu(this: API, user: User["id"] | User, config?: Config): Promise<User.KudosuHistory[]>;
    /**
     * Get user data of each friend of the authorized user
     * @scope {@link Scope"friends.read"}
     */
    function getFriends(this: API): Promise<User.WithCountryCoverGroupsStatisticsSupport[]>;
}
