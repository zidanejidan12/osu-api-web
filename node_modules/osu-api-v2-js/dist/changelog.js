var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
export var Changelog;
(function (Changelog) {
    let Build;
    (function (Build) {
        /**
         * Get details about the version/update/build of something related to osu!
         * @param changelog A stream name like `lazer`, a build version like `2023.1026.0`, or the id of a build
         * @param message_formats `changelog_entries` will have a `message` property if `markdown`, `message_html` property if `html` (defaults to **both**)
         */
        function lookup(changelog, message_formats = ["html", "markdown"]) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("get", `changelog/${changelog}`, { key: typeof changelog === "number" ? "id" : undefined, message_formats });
            });
        }
        Build.lookup = lookup;
        /**
         * Get details about the version/update/build of something related to osu!
         * @param stream The name of the thing related to osu!, like `lazer`, `web`, `cuttingedge`, `beta40`, `stable40`
         * @param build The name of the version! Usually something like `2023.1026.0` for lazer, or `20230326` for stable
         */
        function getOne(stream, build) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("get", `changelog/${stream}/${build}`);
            });
        }
        Build.getOne = getOne;
        /**
         * Get up to 21 versions/updates/builds!
         * @param stream Only get builds from a specific stream
         * @param range Get builds that were released before/after (and including) those builds
         * @param message_formats `changelog_entries` will have a `message` property if `markdown`, `message_html` property if `html` (defaults to **both**)
         */
        function getMultiple(stream, range, message_formats = ["html", "markdown"]) {
            return __awaiter(this, void 0, void 0, function* () {
                const from = range === null || range === void 0 ? void 0 : range.from;
                const to = typeof (range === null || range === void 0 ? void 0 : range.to) === "string" ? range.to : undefined;
                const max_id = typeof (range === null || range === void 0 ? void 0 : range.to) === "number" ? range.to : undefined;
                const response = yield this.request("get", "changelog", { from, to, max_id, stream, message_formats });
                return response.builds; // NOT the only property; `streams` is irrelevant while `search` is useless
            });
        }
        Build.getMultiple = getMultiple;
    })(Build = Changelog.Build || (Changelog.Build = {}));
    let UpdateStream;
    (function (UpdateStream) {
        /**
         * An effective way to get all available streams, as well as their latest version!
         * @example
         * ```ts
         * const names_of_streams = (await api.getChangelogStreams()).map(s => s.name)
         * ```
         */
        function getAll() {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.request("get", "changelog", { max_id: 0 }); // Limit how many `builds` we receive, for the sake of speed
                return response.streams; // NOT the only property; both `builds` and `search` are irrelevant
            });
        }
        UpdateStream.getAll = getAll;
    })(UpdateStream = Changelog.UpdateStream || (Changelog.UpdateStream = {}));
})(Changelog || (Changelog = {}));
