var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
export var Ruleset;
(function (Ruleset) {
    Ruleset[Ruleset["osu"] = 0] = "osu";
    Ruleset[Ruleset["taiko"] = 1] = "taiko";
    Ruleset[Ruleset["fruits"] = 2] = "fruits";
    Ruleset[Ruleset["mania"] = 3] = "mania";
})(Ruleset || (Ruleset = {}));
export var Spotlight;
(function (Spotlight) {
    /**
     * Get ALL legacy spotlights! (2009-2020, somewhat known as charts/ranking charts, available @ https://osu.ppy.sh/rankings/osu/charts)
     * @remarks The data for newer spotlights (2020-, somewhat known as seasons) can be obtained through `getRoom()`
     * but you can't really get the id of those newer spotlights without going through the website's URLs (https://osu.ppy.sh/seasons/latest) as far as I know :(
     */
    function getAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.request("get", "spotlights");
            return response.spotlights; // It's the only property
        });
    }
    Spotlight.getAll = getAll;
})(Spotlight || (Spotlight = {}));
// PRIVATE TO PACKAGE USERS
/**
 * When using `fetch()` for a GET request, you can't just give the parameters the same way you'd give them for a POST request!
 * @param parameters The parameters as they'd be for a POST request (prior to using `JSON.stringify`)
 * @returns Parameters adapted for a GET request
 */
export function adaptParametersForGETRequests(parameters) {
    // If a parameter is an empty string or is undefined, remove it
    for (let i = 0; i < Object.entries(parameters).length; i++) {
        if (!String(Object.values(parameters)[i]).length || Object.values(parameters)[i] === undefined) {
            delete parameters[Object.keys(parameters)[i]];
            i--;
        }
    }
    // If a parameter is an Array, add "[]" to its name, so the server understands the request properly
    for (let i = 0; i < Object.entries(parameters).length; i++) {
        if (Array.isArray(Object.values(parameters)[i]) && !Object.keys(parameters)[i].includes("[]")) {
            parameters[`${Object.keys(parameters)[i]}[]`] = Object.values(parameters)[i];
            delete parameters[Object.keys(parameters)[i]];
            i--;
        }
    }
    // If a parameter is an object, add its properties in "[]" such as "cursor[id]=5&cursor[score]=36.234"
    let parameters_to_add = {};
    for (let i = 0; i < Object.entries(parameters).length; i++) {
        const value = Object.values(parameters)[i];
        if (typeof value === "object" && !Array.isArray(value) && value !== null) {
            const main_name = Object.keys(parameters)[i];
            for (let e = 0; e < Object.entries(value).length; e++) {
                parameters_to_add[`${main_name}[${Object.keys(value)[e]}]`] = Object.values(value)[e];
            }
            delete parameters[Object.keys(parameters)[i]];
            i--;
        }
    }
    for (let i = 0; i < Object.entries(parameters_to_add).length; i++) {
        parameters[Object.keys(parameters_to_add)[i]] = Object.values(parameters_to_add)[i];
    }
    // If a parameter is a date, make it a string
    for (let i = 0; i < Object.entries(parameters).length; i++) {
        if (Object.values(parameters)[i] instanceof Date) {
            parameters[Object.keys(parameters)[i]] = Object.values(parameters)[i].toISOString();
        }
    }
    return parameters;
}
/**
 * Some stuff doesn't have the right type to begin with, such as dates, which are being returned as strings, this fixes that
 * @param x Anything, but should be a string, an array that contains a string, or an object which has a string
 * @returns x, but with it (or what it contains) now having the correct type
 */
export function correctType(x) {
    const bannedProperties = [
        "name", "artist", "title", "location", "interests", "occupation", "twitter",
        "discord", "version", "author", "raw", "bbcode", "title", "message", "creator", "source"
    ];
    if (typeof x === "boolean") {
        return x;
    }
    else if (/^[+-[0-9][0-9]+-[0-9]{2}-[0-9]{2}($|[ T].*)/.test(x)) {
        if (/[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(x))
            x += "Z";
        if (/[0-9]{2}:[0-9]{2}:[0-9]{2}\+[0-9]{2}:[0-9]{2}$/.test(x))
            x = x.substring(0, x.indexOf("+")) + "Z";
        return new Date(x);
    }
    else if (Array.isArray(x)) {
        return x.map((e) => correctType(e));
    }
    else if (!isNaN(x) && x !== "") {
        return x === null ? null : Number(x);
    }
    else if (typeof x === "object" && x !== null) {
        const k = Object.keys(x);
        const v = Object.values(x);
        for (let i = 0; i < k.length; i++) {
            if (typeof v[i] === "string" && bannedProperties.some((p) => k[i].includes(p)))
                continue; // don't turn names made of numbers into integers
            x[k[i]] = correctType(v[i]);
        }
    }
    return x;
}
/**
 * This is an alternative to `AbortSignal.any` that is friendly to older versions of Node.js, it was provided by the kind https://github.com/baileyherbert
 * @param signals The multiple signals you'd want `fetch()` to take
 * @returns A signal that's aborted when any of the `signals` is aborted
 */
export function anySignal(signals) {
    const controller = new AbortController();
    const unsubscribe = [];
    function onAbort(signal) {
        controller.abort(signal.reason);
        unsubscribe.forEach((f) => f());
    }
    for (const signal of signals) {
        if (signal.aborted) {
            onAbort(signal);
            break;
        }
        const handler = onAbort.bind(undefined, signal);
        signal.addEventListener("abort", handler);
        unsubscribe.push(() => signal.removeEventListener("abort", handler));
    }
    return controller.signal;
}
/**
 * A function that makes it easy to get the id from the argument of a function
 * @param arg The id or the object with the id
 * @returns The id
 */
export function getId(arg, property_name = "id") {
    return typeof arg === "number" ? arg : arg[property_name];
}
