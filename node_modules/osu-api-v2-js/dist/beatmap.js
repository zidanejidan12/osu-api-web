var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Ruleset } from "./index.js";
import { getId } from "./misc.js";
export var Beatmap;
(function (Beatmap) {
    let Pack;
    (function (Pack) {
        /**
         * Get data about a Beatmap.Pack using its tag!
         * @param pack The Pack or the pack tag of the Pack you're trying to get
         * @param legacy_only Should lazer scores be excluded from the pack's `user_completion_data`? (defaults to **false**)
         * @remarks Currently in https://osu.ppy.sh/beatmaps/packs, when hovering a pack, its URL with its tag should be preview by your browser
         */
        function getOne(pack, legacy_only = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const tag = typeof pack === "string" ? pack : pack.tag;
                return yield this.request("get", `beatmaps/packs/${tag}`, { legacy_only });
            });
        }
        Pack.getOne = getOne;
        /**
         * Get an Array of up to 100 Beatmap.Packs of a specific type!
         * @param type The type of the BeatmapPacks (defaults to **standard**)
         * @param cursor_string Use a response's `cursor_string` with the same parameters to get the next "page" of results!
         */
        function getMultiple(type = "standard", cursor_string) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.request("get", "beatmaps/packs", { type, cursor_string });
            });
        }
        Pack.getMultiple = getMultiple;
    })(Pack = Beatmap.Pack || (Beatmap.Pack = {}));
    let DifficultyAttributes;
    (function (DifficultyAttributes) {
        /**
         * Get various data about the difficulty of a beatmap!
         * @param beatmap The Beatmap in question
         * @param mods Can be a bitset of mods, an array of mod acronyms, or an array of Mods (ignores mod settings) (defaults to **No Mod**)
         * @param ruleset Useful to specify if the beatmap is a convert (defaults to **the ruleset the beatmap was intended for**)
         * @remarks You may want to use api.getBeatmapDifficultyAttributesOsu (or Taiko or whatever) instead for better type safety
         */
        function get(beatmap, mods, ruleset) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.request("post", `beatmaps/${getId(beatmap)}/attributes`, { ruleset_id: ruleset, mods });
                return response.attributes; // It's the only property
            });
        }
        DifficultyAttributes.get = get;
        /**
         * Get various data about the difficulty of an osu! beatmap!
         * @param beatmap The Beatmap in question
         * @param mods Can be a bitset of mods, an array of mod acronyms, or an array of Mods (ignores mod settings) (defaults to **No Mod**)
         */
        function getOsu(beatmap, mods) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.getBeatmapDifficultyAttributes(beatmap, mods, Ruleset.osu);
            });
        }
        DifficultyAttributes.getOsu = getOsu;
        /**
         * Get various data about the difficulty of a taiko beatmap!
         * @param beatmap The Beatmap in question
         * @param mods Can be a bitset of mods, an array of mod acronyms, or an array of Mods (ignores mod settings) (defaults to **No Mod**)
         */
        function getTaiko(beatmap, mods) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.getBeatmapDifficultyAttributes(beatmap, mods, Ruleset.taiko);
            });
        }
        DifficultyAttributes.getTaiko = getTaiko;
        /**
         * Get various data about the difficulty of a ctb beatmap!
         * @param beatmap The Beatmap in question
         * @param mods Can be a bitset of mods, an array of mod acronyms, or an array of Mods (ignores mod settings) (defaults to **No Mod**)
         */
        function getFruits(beatmap, mods) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.getBeatmapDifficultyAttributes(beatmap, mods, Ruleset.fruits);
            });
        }
        DifficultyAttributes.getFruits = getFruits;
        /**
         * Get various data about the difficulty of a mania beatmap!
         * @param beatmap The Beatmap in question
         * @param mods Can be a bitset of mods, an array of mod acronyms, or an array of Mods (ignores mod settings) (defaults to **No Mod**)
         */
        function getMania(beatmap, mods) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.getBeatmapDifficultyAttributes(beatmap, mods, Ruleset.mania);
            });
        }
        DifficultyAttributes.getMania = getMania;
    })(DifficultyAttributes = Beatmap.DifficultyAttributes || (Beatmap.DifficultyAttributes = {}));
    let UserScore;
    (function (UserScore) {
        /**
         * Get the score on a beatmap made by a specific user (with specific mods and on a specific ruleset if needed)
         * @param beatmap The Beatmap the score was made on
         * @param user The User who made the score
         * @param config Specify the score's ruleset, the score's mods, prevent a lazer score from being returned **(`type` should not be supported)**
         * @returns An Object with the position of the score according to the specified Mods and Ruleset, and with the score itself
         */
        function getOne(beatmap, user, config) {
            return __awaiter(this, void 0, void 0, function* () {
                const mode = (config === null || config === void 0 ? void 0 : config.ruleset) !== undefined ? Ruleset[config.ruleset] : undefined;
                return yield this.request("get", `beatmaps/${getId(beatmap)}/scores/users/${getId(user)}`, { legacy_only: config === null || config === void 0 ? void 0 : config.legacy_only, mode, mods: config === null || config === void 0 ? void 0 : config.mods, type: config === null || config === void 0 ? void 0 : config.type });
            });
        }
        UserScore.getOne = getOne;
        /**
         * Get the scores on a beatmap made by a specific user (with the possibility to specify if the scores are on a convert)
         * @param beatmap The Beatmap the scores were made on
         * @param user The User who made the scores
         * @param config Specify the score's ruleset, prevent a lazer score from being returned **(`mods` and `type` should not be supported)**
         */
        function getMultiple(beatmap, user, config) {
            return __awaiter(this, void 0, void 0, function* () {
                const mode = (config === null || config === void 0 ? void 0 : config.ruleset) !== undefined ? Ruleset[config.ruleset] : undefined;
                const response = yield this.request("get", `beatmaps/${getId(beatmap)}/scores/users/${getId(user)}/all`, { legacy_only: config === null || config === void 0 ? void 0 : config.legacy_only, mode, mods: config === null || config === void 0 ? void 0 : config.mods, type: config === null || config === void 0 ? void 0 : config.type });
                return response.scores; // It's the only property
            });
        }
        UserScore.getMultiple = getMultiple;
    })(UserScore = Beatmap.UserScore || (Beatmap.UserScore = {}));
    /**
     * Get extensive beatmap data about whichever beatmap you want!
     * @param query What to specify in order to find the right beatmap
    */
    function lookup(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request("get", `beatmaps/lookup`, { checksum: query.checksum, filename: query.filename, id: query.id ? String(query.id) : undefined });
        });
    }
    Beatmap.lookup = lookup;
    /**
     * Get extensive beatmap data about whichever beatmap you want!
     * @param beatmap The beatmap or the id of the beatmap you're trying to get
     */
    function getOne(beatmap) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request("get", `beatmaps/${getId(beatmap)}`);
        });
    }
    Beatmap.getOne = getOne;
    /**
     * Get extensive beatmap data for up to 50 beatmaps at once!
     * @param beatmaps An array of beatmaps or of objects that have the id of the beatmaps you're trying to get
     */
    function getMultiple(beatmaps) {
        return __awaiter(this, void 0, void 0, function* () {
            const ids = beatmaps.map((beatmap) => getId(beatmap));
            const response = yield this.request("get", "beatmaps", { ids });
            return response.beatmaps; // It's the only property
        });
    }
    Beatmap.getMultiple = getMultiple;
    /**
     * Get the top scores of a beatmap!
     * @param beatmap The Beatmap in question
     * @param config Specify the score's ruleset, mods, type, prevent a lazer score from being returned
     * @remarks Please check if `mods` and `type` seem to be supported or not by the API: https://osu.ppy.sh/docs/index.html#get-beatmap-scores
     */
    function getScores(beatmap, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const mode = (config === null || config === void 0 ? void 0 : config.ruleset) !== undefined ? Ruleset[config.ruleset] : undefined;
            const response = yield this.request("get", `beatmaps/${getId(beatmap)}/scores`, { legacy_only: config === null || config === void 0 ? void 0 : config.legacy_only, mode, mods: config === null || config === void 0 ? void 0 : config.mods, type: config === null || config === void 0 ? void 0 : config.type });
            return response.scores; // It's the only property
        });
    }
    Beatmap.getScores = getScores;
    /**
     * Get the top scores of a beatmap, in the "solo score" format lazer brought with it!
     * More info on GitHub if needed https://github.com/ppy/osu-infrastructure/blob/master/score-submission.md
     * @param beatmap The Beatmap in question
     * @param config Specify the score's ruleset, mods, type **(`legacy_only` should not be supported)**
     * @remarks Please check if `mods` and `type` seem to be supported or not by the API: https://osu.ppy.sh/docs/index.html#get-beatmap-scores-non-legacy
     */
    function getSoloScores(beatmap, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const mode = (config === null || config === void 0 ? void 0 : config.ruleset) !== undefined ? Ruleset[config.ruleset] : undefined;
            const response = yield this.request("get", `beatmaps/${getId(beatmap)}/solo-scores`, { legacy_only: config === null || config === void 0 ? void 0 : config.legacy_only, mode, mods: config === null || config === void 0 ? void 0 : config.mods, type: config === null || config === void 0 ? void 0 : config.type });
            return response.scores; // It's the only property
        });
    }
    Beatmap.getSoloScores = getSoloScores;
})(Beatmap || (Beatmap = {}));
